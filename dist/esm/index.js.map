{"version":3,"file":"index.js","sources":["../../node_modules/css-tree/cjs/tokenizer/types.cjs","../../node_modules/css-tree/cjs/tokenizer/char-code-definitions.cjs","../../node_modules/css-tree/cjs/tokenizer/utils.cjs","../../node_modules/css-tree/cjs/tokenizer/names.cjs","../../node_modules/css-tree/cjs/tokenizer/adopt-buffer.cjs","../../node_modules/css-tree/cjs/tokenizer/OffsetToLocation.cjs","../../node_modules/css-tree/cjs/tokenizer/TokenStream.cjs","../../node_modules/css-tree/cjs/tokenizer/index.cjs","../../node_modules/css-tree/cjs/utils/List.cjs","../../node_modules/css-tree/cjs/utils/create-custom-error.cjs","../../node_modules/css-tree/cjs/parser/SyntaxError.cjs","../../node_modules/css-tree/cjs/parser/sequence.cjs","../../node_modules/css-tree/cjs/parser/create.cjs","../../../../node_modules/source-map-js/lib/base64.js","../../../../node_modules/source-map-js/lib/base64-vlq.js","../../../../node_modules/source-map-js/lib/util.js","../../../../node_modules/source-map-js/lib/array-set.js","../../../../node_modules/source-map-js/lib/mapping-list.js","../../../../node_modules/source-map-js/lib/source-map-generator.js","../../node_modules/css-tree/cjs/generator/sourceMap.cjs","../../node_modules/css-tree/cjs/generator/token-before.cjs","../../node_modules/css-tree/cjs/generator/create.cjs","../../node_modules/css-tree/cjs/convertor/create.cjs","../../node_modules/css-tree/cjs/walker/create.cjs","../../node_modules/css-tree/cjs/definition-syntax/generate.cjs","../../node_modules/css-tree/cjs/lexer/error.cjs","../../node_modules/css-tree/cjs/utils/names.cjs","../../node_modules/css-tree/cjs/lexer/generic-const.cjs","../../node_modules/css-tree/cjs/lexer/generic-an-plus-b.cjs","../../node_modules/css-tree/cjs/lexer/generic-urange.cjs","../../node_modules/css-tree/cjs/lexer/generic.cjs","../../node_modules/css-tree/cjs/lexer/units.cjs","../../node_modules/css-tree/cjs/lexer/prepare-tokens.cjs","../../node_modules/css-tree/cjs/definition-syntax/SyntaxError.cjs","../../node_modules/css-tree/cjs/definition-syntax/tokenizer.cjs","../../node_modules/css-tree/cjs/definition-syntax/parse.cjs","../../node_modules/css-tree/cjs/lexer/match-graph.cjs","../../node_modules/css-tree/cjs/lexer/match.cjs","../../node_modules/css-tree/cjs/lexer/trace.cjs","../../node_modules/css-tree/cjs/lexer/search.cjs","../../node_modules/css-tree/cjs/lexer/structure.cjs","../../node_modules/css-tree/cjs/definition-syntax/walk.cjs","../../node_modules/css-tree/cjs/lexer/Lexer.cjs","../../node_modules/css-tree/cjs/syntax/config/mix.cjs","../../node_modules/css-tree/cjs/syntax/create.cjs","../../node_modules/css-tree/cjs/data.cjs","../../node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs","../../node_modules/css-tree/cjs/syntax/node/Atrule.cjs","../../node_modules/css-tree/cjs/syntax/node/AtrulePrelude.cjs","../../node_modules/css-tree/cjs/syntax/node/AttributeSelector.cjs","../../node_modules/css-tree/cjs/syntax/node/Block.cjs","../../node_modules/css-tree/cjs/syntax/node/Brackets.cjs","../../node_modules/css-tree/cjs/syntax/node/CDC.cjs","../../node_modules/css-tree/cjs/syntax/node/CDO.cjs","../../node_modules/css-tree/cjs/syntax/node/ClassSelector.cjs","../../node_modules/css-tree/cjs/syntax/node/Combinator.cjs","../../node_modules/css-tree/cjs/syntax/node/Comment.cjs","../../node_modules/css-tree/cjs/syntax/node/Declaration.cjs","../../node_modules/css-tree/cjs/syntax/node/DeclarationList.cjs","../../node_modules/css-tree/cjs/syntax/node/Dimension.cjs","../../node_modules/css-tree/cjs/syntax/node/Function.cjs","../../node_modules/css-tree/cjs/syntax/node/Hash.cjs","../../node_modules/css-tree/cjs/syntax/node/Identifier.cjs","../../node_modules/css-tree/cjs/syntax/node/IdSelector.cjs","../../node_modules/css-tree/cjs/syntax/node/MediaFeature.cjs","../../node_modules/css-tree/cjs/syntax/node/MediaQuery.cjs","../../node_modules/css-tree/cjs/syntax/node/MediaQueryList.cjs","../../node_modules/css-tree/cjs/syntax/node/NestingSelector.cjs","../../node_modules/css-tree/cjs/syntax/node/Nth.cjs","../../node_modules/css-tree/cjs/syntax/node/Number.cjs","../../node_modules/css-tree/cjs/syntax/node/Operator.cjs","../../node_modules/css-tree/cjs/syntax/node/Parentheses.cjs","../../node_modules/css-tree/cjs/syntax/node/Percentage.cjs","../../node_modules/css-tree/cjs/syntax/node/PseudoClassSelector.cjs","../../node_modules/css-tree/cjs/syntax/node/PseudoElementSelector.cjs","../../node_modules/css-tree/cjs/syntax/node/Ratio.cjs","../../node_modules/css-tree/cjs/syntax/node/Raw.cjs","../../node_modules/css-tree/cjs/syntax/node/Rule.cjs","../../node_modules/css-tree/cjs/syntax/node/Selector.cjs","../../node_modules/css-tree/cjs/syntax/node/SelectorList.cjs","../../node_modules/css-tree/cjs/utils/string.cjs","../../node_modules/css-tree/cjs/syntax/node/String.cjs","../../node_modules/css-tree/cjs/syntax/node/StyleSheet.cjs","../../node_modules/css-tree/cjs/syntax/node/TypeSelector.cjs","../../node_modules/css-tree/cjs/syntax/node/UnicodeRange.cjs","../../node_modules/css-tree/cjs/utils/url.cjs","../../node_modules/css-tree/cjs/syntax/node/Url.cjs","../../node_modules/css-tree/cjs/syntax/node/Value.cjs","../../node_modules/css-tree/cjs/syntax/node/WhiteSpace.cjs","../../node_modules/css-tree/cjs/syntax/node/index.cjs","../../node_modules/css-tree/cjs/syntax/config/lexer.cjs","../../node_modules/css-tree/cjs/syntax/scope/default.cjs","../../node_modules/css-tree/cjs/syntax/scope/selector.cjs","../../node_modules/css-tree/cjs/syntax/function/var.cjs","../../node_modules/css-tree/cjs/syntax/scope/value.cjs","../../node_modules/css-tree/cjs/syntax/scope/index.cjs","../../node_modules/css-tree/cjs/syntax/scope/atrulePrelude.cjs","../../node_modules/css-tree/cjs/syntax/function/expression.cjs","../../node_modules/css-tree/cjs/syntax/atrule/import.cjs","../../node_modules/css-tree/cjs/syntax/atrule/supports.cjs","../../node_modules/css-tree/cjs/syntax/atrule/index.cjs","../../node_modules/css-tree/cjs/syntax/atrule/font-face.cjs","../../node_modules/css-tree/cjs/syntax/atrule/media.cjs","../../node_modules/css-tree/cjs/syntax/atrule/nest.cjs","../../node_modules/css-tree/cjs/syntax/atrule/page.cjs","../../node_modules/css-tree/cjs/syntax/pseudo/index.cjs","../../node_modules/css-tree/cjs/syntax/node/index-parse.cjs","../../node_modules/css-tree/cjs/syntax/index.cjs","../../node_modules/css-tree/cjs/syntax/config/parser.cjs","../../node_modules/css-tree/cjs/syntax/config/walker.cjs","../../node_modules/css-tree/cjs/definition-syntax/index.cjs","../../node_modules/css-tree/cjs/utils/ident.cjs","../../node_modules/css-tree/cjs/index.cjs","../../src/components/MatchGraph/MatchGraph.tsx"],"sourcesContent":["'use strict';\n\n// CSS Syntax Module Level 3\n// https://www.w3.org/TR/css-syntax-3/\nconst EOF = 0;                 // <EOF-token>\nconst Ident = 1;               // <ident-token>\nconst Function = 2;            // <function-token>\nconst AtKeyword = 3;           // <at-keyword-token>\nconst Hash = 4;                // <hash-token>\nconst String = 5;              // <string-token>\nconst BadString = 6;           // <bad-string-token>\nconst Url = 7;                 // <url-token>\nconst BadUrl = 8;              // <bad-url-token>\nconst Delim = 9;               // <delim-token>\nconst Number = 10;             // <number-token>\nconst Percentage = 11;         // <percentage-token>\nconst Dimension = 12;          // <dimension-token>\nconst WhiteSpace = 13;         // <whitespace-token>\nconst CDO = 14;                // <CDO-token>\nconst CDC = 15;                // <CDC-token>\nconst Colon = 16;              // <colon-token>     :\nconst Semicolon = 17;          // <semicolon-token> ;\nconst Comma = 18;              // <comma-token>     ,\nconst LeftSquareBracket = 19;  // <[-token>\nconst RightSquareBracket = 20; // <]-token>\nconst LeftParenthesis = 21;    // <(-token>\nconst RightParenthesis = 22;   // <)-token>\nconst LeftCurlyBracket = 23;   // <{-token>\nconst RightCurlyBracket = 24;  // <}-token>\nconst Comment = 25;\n\nexports.AtKeyword = AtKeyword;\nexports.BadString = BadString;\nexports.BadUrl = BadUrl;\nexports.CDC = CDC;\nexports.CDO = CDO;\nexports.Colon = Colon;\nexports.Comma = Comma;\nexports.Comment = Comment;\nexports.Delim = Delim;\nexports.Dimension = Dimension;\nexports.EOF = EOF;\nexports.Function = Function;\nexports.Hash = Hash;\nexports.Ident = Ident;\nexports.LeftCurlyBracket = LeftCurlyBracket;\nexports.LeftParenthesis = LeftParenthesis;\nexports.LeftSquareBracket = LeftSquareBracket;\nexports.Number = Number;\nexports.Percentage = Percentage;\nexports.RightCurlyBracket = RightCurlyBracket;\nexports.RightParenthesis = RightParenthesis;\nexports.RightSquareBracket = RightSquareBracket;\nexports.Semicolon = Semicolon;\nexports.String = String;\nexports.Url = Url;\nexports.WhiteSpace = WhiteSpace;\n","'use strict';\n\nconst EOF = 0;\n\n// https://drafts.csswg.org/css-syntax-3/\n// § 4.2. Definitions\n\n// digit\n// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).\nfunction isDigit(code) {\n    return code >= 0x0030 && code <= 0x0039;\n}\n\n// hex digit\n// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),\n// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).\nfunction isHexDigit(code) {\n    return (\n        isDigit(code) || // 0 .. 9\n        (code >= 0x0041 && code <= 0x0046) || // A .. F\n        (code >= 0x0061 && code <= 0x0066)    // a .. f\n    );\n}\n\n// uppercase letter\n// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).\nfunction isUppercaseLetter(code) {\n    return code >= 0x0041 && code <= 0x005A;\n}\n\n// lowercase letter\n// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).\nfunction isLowercaseLetter(code) {\n    return code >= 0x0061 && code <= 0x007A;\n}\n\n// letter\n// An uppercase letter or a lowercase letter.\nfunction isLetter(code) {\n    return isUppercaseLetter(code) || isLowercaseLetter(code);\n}\n\n// non-ASCII code point\n// A code point with a value equal to or greater than U+0080 <control>.\nfunction isNonAscii(code) {\n    return code >= 0x0080;\n}\n\n// name-start code point\n// A letter, a non-ASCII code point, or U+005F LOW LINE (_).\nfunction isNameStart(code) {\n    return isLetter(code) || isNonAscii(code) || code === 0x005F;\n}\n\n// name code point\n// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).\nfunction isName(code) {\n    return isNameStart(code) || isDigit(code) || code === 0x002D;\n}\n\n// non-printable code point\n// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,\n// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.\nfunction isNonPrintable(code) {\n    return (\n        (code >= 0x0000 && code <= 0x0008) ||\n        (code === 0x000B) ||\n        (code >= 0x000E && code <= 0x001F) ||\n        (code === 0x007F)\n    );\n}\n\n// newline\n// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,\n// as they are converted to U+000A LINE FEED during preprocessing.\n// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED\nfunction isNewline(code) {\n    return code === 0x000A || code === 0x000D || code === 0x000C;\n}\n\n// whitespace\n// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.\nfunction isWhiteSpace(code) {\n    return isNewline(code) || code === 0x0020 || code === 0x0009;\n}\n\n// § 4.3.8. Check if two code points are a valid escape\nfunction isValidEscape(first, second) {\n    // If the first code point is not U+005C REVERSE SOLIDUS (\\), return false.\n    if (first !== 0x005C) {\n        return false;\n    }\n\n    // Otherwise, if the second code point is a newline or EOF, return false.\n    if (isNewline(second) || second === EOF) {\n        return false;\n    }\n\n    // Otherwise, return true.\n    return true;\n}\n\n// § 4.3.9. Check if three code points would start an identifier\nfunction isIdentifierStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002D HYPHEN-MINUS\n    if (first === 0x002D) {\n        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,\n        // or the second and third code points are a valid escape, return true. Otherwise, return false.\n        return (\n            isNameStart(second) ||\n            second === 0x002D ||\n            isValidEscape(second, third)\n        );\n    }\n\n    // name-start code point\n    if (isNameStart(first)) {\n        // Return true.\n        return true;\n    }\n\n    // U+005C REVERSE SOLIDUS (\\)\n    if (first === 0x005C) {\n        // If the first and second code points are a valid escape, return true. Otherwise, return false.\n        return isValidEscape(first, second);\n    }\n\n    // anything else\n    // Return false.\n    return false;\n}\n\n// § 4.3.10. Check if three code points would start a number\nfunction isNumberStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002B PLUS SIGN (+)\n    // U+002D HYPHEN-MINUS (-)\n    if (first === 0x002B || first === 0x002D) {\n        // If the second code point is a digit, return true.\n        if (isDigit(second)) {\n            return 2;\n        }\n\n        // Otherwise, if the second code point is a U+002E FULL STOP (.)\n        // and the third code point is a digit, return true.\n        // Otherwise, return false.\n        return second === 0x002E && isDigit(third) ? 3 : 0;\n    }\n\n    // U+002E FULL STOP (.)\n    if (first === 0x002E) {\n        // If the second code point is a digit, return true. Otherwise, return false.\n        return isDigit(second) ? 2 : 0;\n    }\n\n    // digit\n    if (isDigit(first)) {\n        // Return true.\n        return 1;\n    }\n\n    // anything else\n    // Return false.\n    return 0;\n}\n\n//\n// Misc\n//\n\n// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)\nfunction isBOM(code) {\n    // UTF-16BE\n    if (code === 0xFEFF) {\n        return 1;\n    }\n\n    // UTF-16LE\n    if (code === 0xFFFE) {\n        return 1;\n    }\n\n    return 0;\n}\n\n// Fast code category\n// Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only\nconst CATEGORY = new Array(0x80);\nconst EofCategory = 0x80;\nconst WhiteSpaceCategory = 0x82;\nconst DigitCategory = 0x83;\nconst NameStartCategory = 0x84;\nconst NonPrintableCategory = 0x85;\n\nfor (let i = 0; i < CATEGORY.length; i++) {\n    CATEGORY[i] =\n        isWhiteSpace(i) && WhiteSpaceCategory ||\n        isDigit(i) && DigitCategory ||\n        isNameStart(i) && NameStartCategory ||\n        isNonPrintable(i) && NonPrintableCategory ||\n        i || EofCategory;\n}\n\nfunction charCodeCategory(code) {\n    return code < 0x80 ? CATEGORY[code] : NameStartCategory;\n}\n\nexports.DigitCategory = DigitCategory;\nexports.EofCategory = EofCategory;\nexports.NameStartCategory = NameStartCategory;\nexports.NonPrintableCategory = NonPrintableCategory;\nexports.WhiteSpaceCategory = WhiteSpaceCategory;\nexports.charCodeCategory = charCodeCategory;\nexports.isBOM = isBOM;\nexports.isDigit = isDigit;\nexports.isHexDigit = isHexDigit;\nexports.isIdentifierStart = isIdentifierStart;\nexports.isLetter = isLetter;\nexports.isLowercaseLetter = isLowercaseLetter;\nexports.isName = isName;\nexports.isNameStart = isNameStart;\nexports.isNewline = isNewline;\nexports.isNonAscii = isNonAscii;\nexports.isNonPrintable = isNonPrintable;\nexports.isNumberStart = isNumberStart;\nexports.isUppercaseLetter = isUppercaseLetter;\nexports.isValidEscape = isValidEscape;\nexports.isWhiteSpace = isWhiteSpace;\n","'use strict';\n\nconst charCodeDefinitions = require('./char-code-definitions.cjs');\n\nfunction getCharCode(source, offset) {\n    return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nfunction getNewlineLength(source, offset, code) {\n    if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n        return 2;\n    }\n\n    return 1;\n}\n\nfunction cmpChar(testStr, offset, referenceCode) {\n    let code = testStr.charCodeAt(offset);\n\n    // code.toLowerCase() for A..Z\n    if (charCodeDefinitions.isUppercaseLetter(code)) {\n        code = code | 32;\n    }\n\n    return code === referenceCode;\n}\n\nfunction cmpStr(testStr, start, end, referenceStr) {\n    if (end - start !== referenceStr.length) {\n        return false;\n    }\n\n    if (start < 0 || end > testStr.length) {\n        return false;\n    }\n\n    for (let i = start; i < end; i++) {\n        const referenceCode = referenceStr.charCodeAt(i - start);\n        let testCode = testStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for A..Z\n        if (charCodeDefinitions.isUppercaseLetter(testCode)) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction findWhiteSpaceStart(source, offset) {\n    for (; offset >= 0; offset--) {\n        if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset + 1;\n}\n\nfunction findWhiteSpaceEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nfunction findDecimalNumberEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!charCodeDefinitions.isDigit(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\nfunction consumeEscaped(source, offset) {\n    // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n    // that the next input code point has already been verified to be part of a valid escape.\n    offset += 2;\n\n    // hex digit\n    if (charCodeDefinitions.isHexDigit(getCharCode(source, offset - 1))) {\n        // Consume as many hex digits as possible, but no more than 5.\n        // Note that this means 1-6 hex digits have been consumed in total.\n        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n            if (!charCodeDefinitions.isHexDigit(getCharCode(source, offset))) {\n                break;\n            }\n        }\n\n        // If the next input code point is whitespace, consume it as well.\n        const code = getCharCode(source, offset);\n        if (charCodeDefinitions.isWhiteSpace(code)) {\n            offset += getNewlineLength(source, offset, code);\n        }\n    }\n\n    return offset;\n}\n\n// §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nfunction consumeName(source, offset) {\n    // Let result initially be an empty string.\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        const code = source.charCodeAt(offset);\n\n        // name code point\n        if (charCodeDefinitions.isName(code)) {\n            // Append the code point to result.\n            continue;\n        }\n\n        // the stream starts with a valid escape\n        if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point. Append the returned code point to result.\n            offset = consumeEscaped(source, offset) - 1;\n            continue;\n        }\n\n        // anything else\n        // Reconsume the current input code point. Return result.\n        break;\n    }\n\n    return offset;\n}\n\n// §4.3.12. Consume a number\nfunction consumeNumber(source, offset) {\n    let code = source.charCodeAt(offset);\n\n    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (code === 0x002B || code === 0x002D) {\n        code = source.charCodeAt(offset += 1);\n    }\n\n    // 3. While the next input code point is a digit, consume it and append it to repr.\n    if (charCodeDefinitions.isDigit(code)) {\n        offset = findDecimalNumberEnd(source, offset + 1);\n        code = source.charCodeAt(offset);\n    }\n\n    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && charCodeDefinitions.isDigit(source.charCodeAt(offset + 1))) {\n        // 4.1 Consume them.\n        // 4.2 Append them to repr.\n        offset += 2;\n\n        // 4.3 Set type to \"number\".\n        // TODO\n\n        // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n        offset = findDecimalNumberEnd(source, offset);\n    }\n\n    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    if (cmpChar(source, offset, 101 /* e */)) {\n        let sign = 0;\n        code = source.charCodeAt(offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (code === 0x002D || code === 0x002B) {\n            sign = 1;\n            code = source.charCodeAt(offset + 2);\n        }\n\n        // ... followed by a digit\n        if (charCodeDefinitions.isDigit(code)) {\n            // 5.1 Consume them.\n            // 5.2 Append them to repr.\n\n            // 5.3 Set type to \"number\".\n            // TODO\n\n            // 5.4 While the next input code point is a digit, consume it and append it to repr.\n            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nfunction consumeBadUrlRemnants(source, offset) {\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        const code = source.charCodeAt(offset);\n\n        // U+0029 RIGHT PARENTHESIS ())\n        // EOF\n        if (code === 0x0029) {\n            // Return.\n            offset++;\n            break;\n        }\n\n        if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point.\n            // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n            // without ending the <bad-url-token>. This is otherwise identical to\n            // the \"anything else\" clause.\n            offset = consumeEscaped(source, offset);\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\n// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\\)\nfunction decodeEscaped(escaped) {\n    // Single char escaped that's not a hex digit\n    if (escaped.length === 1 && !charCodeDefinitions.isHexDigit(escaped.charCodeAt(0))) {\n        return escaped[0];\n    }\n\n    // Interpret the hex digits as a hexadecimal number.\n    let code = parseInt(escaped, 16);\n\n    if (\n        (code === 0) ||                       // If this number is zero,\n        (code >= 0xD800 && code <= 0xDFFF) || // or is for a surrogate,\n        (code > 0x10FFFF)                     // or is greater than the maximum allowed code point\n    ) {\n        // ... return U+FFFD REPLACEMENT CHARACTER\n        code = 0xFFFD;\n    }\n\n    // Otherwise, return the code point with that value.\n    return String.fromCodePoint(code);\n}\n\nexports.cmpChar = cmpChar;\nexports.cmpStr = cmpStr;\nexports.consumeBadUrlRemnants = consumeBadUrlRemnants;\nexports.consumeEscaped = consumeEscaped;\nexports.consumeName = consumeName;\nexports.consumeNumber = consumeNumber;\nexports.decodeEscaped = decodeEscaped;\nexports.findDecimalNumberEnd = findDecimalNumberEnd;\nexports.findWhiteSpaceEnd = findWhiteSpaceEnd;\nexports.findWhiteSpaceStart = findWhiteSpaceStart;\nexports.getNewlineLength = getNewlineLength;\n","'use strict';\n\nconst tokenNames = [\n    'EOF-token',\n    'ident-token',\n    'function-token',\n    'at-keyword-token',\n    'hash-token',\n    'string-token',\n    'bad-string-token',\n    'url-token',\n    'bad-url-token',\n    'delim-token',\n    'number-token',\n    'percentage-token',\n    'dimension-token',\n    'whitespace-token',\n    'CDO-token',\n    'CDC-token',\n    'colon-token',\n    'semicolon-token',\n    'comma-token',\n    '[-token',\n    ']-token',\n    '(-token',\n    ')-token',\n    '{-token',\n    '}-token'\n];\n\nmodule.exports = tokenNames;\n","'use strict';\n\nconst MIN_SIZE = 16 * 1024;\n\nfunction adoptBuffer(buffer = null, size) {\n    if (buffer === null || buffer.length < size) {\n        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));\n    }\n\n    return buffer;\n}\n\nexports.adoptBuffer = adoptBuffer;\n","'use strict';\n\nconst adoptBuffer = require('./adopt-buffer.cjs');\nconst charCodeDefinitions = require('./char-code-definitions.cjs');\n\nconst N = 10;\nconst F = 12;\nconst R = 13;\n\nfunction computeLinesAndColumns(host) {\n    const source = host.source;\n    const sourceLength = source.length;\n    const startOffset = source.length > 0 ? charCodeDefinitions.isBOM(source.charCodeAt(0)) : 0;\n    const lines = adoptBuffer.adoptBuffer(host.lines, sourceLength);\n    const columns = adoptBuffer.adoptBuffer(host.columns, sourceLength);\n    let line = host.startLine;\n    let column = host.startColumn;\n\n    for (let i = startOffset; i < sourceLength; i++) {\n        const code = source.charCodeAt(i);\n\n        lines[i] = line;\n        columns[i] = column++;\n\n        if (code === N || code === R || code === F) {\n            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {\n                i++;\n                lines[i] = line;\n                columns[i] = column;\n            }\n\n            line++;\n            column = 1;\n        }\n    }\n\n    lines[sourceLength] = line;\n    columns[sourceLength] = column;\n\n    host.lines = lines;\n    host.columns = columns;\n    host.computed = true;\n}\n\nclass OffsetToLocation {\n    constructor() {\n        this.lines = null;\n        this.columns = null;\n        this.computed = false;\n    }\n    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {\n        this.source = source;\n        this.startOffset = startOffset;\n        this.startLine = startLine;\n        this.startColumn = startColumn;\n        this.computed = false;\n    }\n    getLocation(offset, filename) {\n        if (!this.computed) {\n            computeLinesAndColumns(this);\n        }\n\n        return {\n            source: filename,\n            offset: this.startOffset + offset,\n            line: this.lines[offset],\n            column: this.columns[offset]\n        };\n    }\n    getLocationRange(start, end, filename) {\n        if (!this.computed) {\n            computeLinesAndColumns(this);\n        }\n\n        return {\n            source: filename,\n            start: {\n                offset: this.startOffset + start,\n                line: this.lines[start],\n                column: this.columns[start]\n            },\n            end: {\n                offset: this.startOffset + end,\n                line: this.lines[end],\n                column: this.columns[end]\n            }\n        };\n    }\n}\n\nexports.OffsetToLocation = OffsetToLocation;\n","'use strict';\n\nconst adoptBuffer = require('./adopt-buffer.cjs');\nconst utils = require('./utils.cjs');\nconst names = require('./names.cjs');\nconst types = require('./types.cjs');\n\nconst OFFSET_MASK = 0x00FFFFFF;\nconst TYPE_SHIFT = 24;\nconst balancePair = new Map([\n    [types.Function, types.RightParenthesis],\n    [types.LeftParenthesis, types.RightParenthesis],\n    [types.LeftSquareBracket, types.RightSquareBracket],\n    [types.LeftCurlyBracket, types.RightCurlyBracket]\n]);\n\nclass TokenStream {\n    constructor(source, tokenize) {\n        this.setSource(source, tokenize);\n    }\n    reset() {\n        this.eof = false;\n        this.tokenIndex = -1;\n        this.tokenType = 0;\n        this.tokenStart = this.firstCharOffset;\n        this.tokenEnd = this.firstCharOffset;\n    }\n    setSource(source = '', tokenize = () => {}) {\n        source = String(source || '');\n\n        const sourceLength = source.length;\n        const offsetAndType = adoptBuffer.adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token\n        const balance = adoptBuffer.adoptBuffer(this.balance, source.length + 1);\n        let tokenCount = 0;\n        let balanceCloseType = 0;\n        let balanceStart = 0;\n        let firstCharOffset = -1;\n\n        // capture buffers\n        this.offsetAndType = null;\n        this.balance = null;\n\n        tokenize(source, (type, start, end) => {\n            switch (type) {\n                default:\n                    balance[tokenCount] = sourceLength;\n                    break;\n\n                case balanceCloseType: {\n                    let balancePrev = balanceStart & OFFSET_MASK;\n                    balanceStart = balance[balancePrev];\n                    balanceCloseType = balanceStart >> TYPE_SHIFT;\n                    balance[tokenCount] = balancePrev;\n                    balance[balancePrev++] = tokenCount;\n                    for (; balancePrev < tokenCount; balancePrev++) {\n                        if (balance[balancePrev] === sourceLength) {\n                            balance[balancePrev] = tokenCount;\n                        }\n                    }\n                    break;\n                }\n\n                case types.LeftParenthesis:\n                case types.Function:\n                case types.LeftSquareBracket:\n                case types.LeftCurlyBracket:\n                    balance[tokenCount] = balanceStart;\n                    balanceCloseType = balancePair.get(type);\n                    balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;\n                    break;\n            }\n\n            offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | end;\n            if (firstCharOffset === -1) {\n                firstCharOffset = start;\n            }\n        });\n\n        // finalize buffers\n        offsetAndType[tokenCount] = (types.EOF << TYPE_SHIFT) | sourceLength; // <EOF-token>\n        balance[tokenCount] = sourceLength;\n        balance[sourceLength] = sourceLength; // prevents false positive balance match with any token\n        while (balanceStart !== 0) {\n            const balancePrev = balanceStart & OFFSET_MASK;\n            balanceStart = balance[balancePrev];\n            balance[balancePrev] = sourceLength;\n        }\n\n        this.source = source;\n        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;\n        this.tokenCount = tokenCount;\n        this.offsetAndType = offsetAndType;\n        this.balance = balance;\n\n        this.reset();\n        this.next();\n    }\n\n    lookupType(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset] >> TYPE_SHIFT;\n        }\n\n        return types.EOF;\n    }\n    lookupOffset(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset - 1] & OFFSET_MASK;\n        }\n\n        return this.source.length;\n    }\n    lookupValue(offset, referenceStr) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return utils.cmpStr(\n                this.source,\n                this.offsetAndType[offset - 1] & OFFSET_MASK,\n                this.offsetAndType[offset] & OFFSET_MASK,\n                referenceStr\n            );\n        }\n\n        return false;\n    }\n    getTokenStart(tokenIndex) {\n        if (tokenIndex === this.tokenIndex) {\n            return this.tokenStart;\n        }\n\n        if (tokenIndex > 0) {\n            return tokenIndex < this.tokenCount\n                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK\n                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n        }\n\n        return this.firstCharOffset;\n    }\n    substrToCursor(start) {\n        return this.source.substring(start, this.tokenStart);\n    }\n\n    isBalanceEdge(pos) {\n        return this.balance[this.tokenIndex] < pos;\n    }\n    isDelim(code, offset) {\n        if (offset) {\n            return (\n                this.lookupType(offset) === types.Delim &&\n                this.source.charCodeAt(this.lookupOffset(offset)) === code\n            );\n        }\n\n        return (\n            this.tokenType === types.Delim &&\n            this.source.charCodeAt(this.tokenStart) === code\n        );\n    }\n\n    skip(tokenCount) {\n        let next = this.tokenIndex + tokenCount;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.next();\n        }\n    }\n    next() {\n        let next = this.tokenIndex + 1;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.tokenEnd;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.eof = true;\n            this.tokenIndex = this.tokenCount;\n            this.tokenType = types.EOF;\n            this.tokenStart = this.tokenEnd = this.source.length;\n        }\n    }\n    skipSC() {\n        while (this.tokenType === types.WhiteSpace || this.tokenType === types.Comment) {\n            this.next();\n        }\n    }\n    skipUntilBalanced(startToken, stopConsume) {\n        let cursor = startToken;\n        let balanceEnd;\n        let offset;\n\n        loop:\n        for (; cursor < this.tokenCount; cursor++) {\n            balanceEnd = this.balance[cursor];\n\n            // stop scanning on balance edge that points to offset before start token\n            if (balanceEnd < startToken) {\n                break loop;\n            }\n\n            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;\n\n            // check stop condition\n            switch (stopConsume(this.source.charCodeAt(offset))) {\n                case 1: // just stop\n                    break loop;\n\n                case 2: // stop & included\n                    cursor++;\n                    break loop;\n\n                default:\n                    // fast forward to the end of balanced block\n                    if (this.balance[balanceEnd] === cursor) {\n                        cursor = balanceEnd;\n                    }\n            }\n        }\n\n        this.skip(cursor - this.tokenIndex);\n    }\n\n    forEachToken(fn) {\n        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n            const start = offset;\n            const item = this.offsetAndType[i];\n            const end = item & OFFSET_MASK;\n            const type = item >> TYPE_SHIFT;\n\n            offset = end;\n\n            fn(type, start, end, i);\n        }\n    }\n    dump() {\n        const tokens = new Array(this.tokenCount);\n\n        this.forEachToken((type, start, end, index) => {\n            tokens[index] = {\n                idx: index,\n                type: names[type],\n                chunk: this.source.substring(start, end),\n                balance: this.balance[index]\n            };\n        });\n\n        return tokens;\n    }\n}\n\nexports.TokenStream = TokenStream;\n","'use strict';\n\nconst types = require('./types.cjs');\nconst charCodeDefinitions = require('./char-code-definitions.cjs');\nconst utils = require('./utils.cjs');\nconst names = require('./names.cjs');\nconst OffsetToLocation = require('./OffsetToLocation.cjs');\nconst TokenStream = require('./TokenStream.cjs');\n\nfunction tokenize(source, onToken) {\n    function getCharCode(offset) {\n        return offset < sourceLength ? source.charCodeAt(offset) : 0;\n    }\n\n    // § 4.3.3. Consume a numeric token\n    function consumeNumericToken() {\n        // Consume a number and let number be the result.\n        offset = utils.consumeNumber(source, offset);\n\n        // If the next 3 input code points would start an identifier, then:\n        if (charCodeDefinitions.isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {\n            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.\n            // Consume a name. Set the <dimension-token>’s unit to the returned value.\n            // Return the <dimension-token>.\n            type = types.Dimension;\n            offset = utils.consumeName(source, offset);\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.\n        if (getCharCode(offset) === 0x0025) {\n            // Create a <percentage-token> with the same value as number, and return it.\n            type = types.Percentage;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.\n        type = types.Number;\n    }\n\n    // § 4.3.4. Consume an ident-like token\n    function consumeIdentLikeToken() {\n        const nameStartOffset = offset;\n\n        // Consume a name, and let string be the result.\n        offset = utils.consumeName(source, offset);\n\n        // If string’s value is an ASCII case-insensitive match for \"url\",\n        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        if (utils.cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {\n            // While the next two input code points are whitespace, consume the next input code point.\n            offset = utils.findWhiteSpaceEnd(source, offset + 1);\n\n            // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('),\n            // or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('),\n            // then create a <function-token> with its value set to string and return it.\n            if (getCharCode(offset) === 0x0022 ||\n                getCharCode(offset) === 0x0027) {\n                type = types.Function;\n                offset = nameStartOffset + 4;\n                return;\n            }\n\n            // Otherwise, consume a url token, and return it.\n            consumeUrlToken();\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        // Create a <function-token> with its value set to string and return it.\n        if (getCharCode(offset) === 0x0028) {\n            type = types.Function;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create an <ident-token> with its value set to string and return it.\n        type = types.Ident;\n    }\n\n    // § 4.3.5. Consume a string token\n    function consumeStringToken(endingCodePoint) {\n        // This algorithm may be called with an ending code point, which denotes the code point\n        // that ends the string. If an ending code point is not specified,\n        // the current input code point is used.\n        if (!endingCodePoint) {\n            endingCodePoint = getCharCode(offset++);\n        }\n\n        // Initially create a <string-token> with its value set to the empty string.\n        type = types.String;\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            const code = source.charCodeAt(offset);\n\n            switch (charCodeDefinitions.charCodeCategory(code)) {\n                // ending code point\n                case endingCodePoint:\n                    // Return the <string-token>.\n                    offset++;\n                    return;\n\n                    // EOF\n                    // case EofCategory:\n                    // This is a parse error. Return the <string-token>.\n                    // return;\n\n                // newline\n                case charCodeDefinitions.WhiteSpaceCategory:\n                    if (charCodeDefinitions.isNewline(code)) {\n                        // This is a parse error. Reconsume the current input code point,\n                        // create a <bad-string-token>, and return it.\n                        offset += utils.getNewlineLength(source, offset, code);\n                        type = types.BadString;\n                        return;\n                    }\n                    break;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the next input code point is EOF, do nothing.\n                    if (offset === source.length - 1) {\n                        break;\n                    }\n\n                    const nextCode = getCharCode(offset + 1);\n\n                    // Otherwise, if the next input code point is a newline, consume it.\n                    if (charCodeDefinitions.isNewline(nextCode)) {\n                        offset += utils.getNewlineLength(source, offset + 1, nextCode);\n                    } else if (charCodeDefinitions.isValidEscape(code, nextCode)) {\n                        // Otherwise, (the stream starts with a valid escape) consume\n                        // an escaped code point and append the returned code point to\n                        // the <string-token>’s value.\n                        offset = utils.consumeEscaped(source, offset) - 1;\n                    }\n                    break;\n\n                // anything else\n                // Append the current input code point to the <string-token>’s value.\n            }\n        }\n    }\n\n    // § 4.3.6. Consume a url token\n    // Note: This algorithm assumes that the initial \"url(\" has already been consumed.\n    // This algorithm also assumes that it’s being called to consume an \"unquoted\" value, like url(foo).\n    // A quoted value, like url(\"foo\"), is parsed as a <function-token>. Consume an ident-like token\n    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.\n    function consumeUrlToken() {\n        // Initially create a <url-token> with its value set to the empty string.\n        type = types.Url;\n\n        // Consume as much whitespace as possible.\n        offset = utils.findWhiteSpaceEnd(source, offset);\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            const code = source.charCodeAt(offset);\n\n            switch (charCodeDefinitions.charCodeCategory(code)) {\n                // U+0029 RIGHT PARENTHESIS ())\n                case 0x0029:\n                    // Return the <url-token>.\n                    offset++;\n                    return;\n\n                    // EOF\n                    // case EofCategory:\n                    // This is a parse error. Return the <url-token>.\n                    // return;\n\n                // whitespace\n                case charCodeDefinitions.WhiteSpaceCategory:\n                    // Consume as much whitespace as possible.\n                    offset = utils.findWhiteSpaceEnd(source, offset);\n\n                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,\n                    // consume it and return the <url-token>\n                    // (if EOF was encountered, this is a parse error);\n                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {\n                        if (offset < source.length) {\n                            offset++;\n                        }\n                        return;\n                    }\n\n                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,\n                    // and return it.\n                    offset = utils.consumeBadUrlRemnants(source, offset);\n                    type = types.BadUrl;\n                    return;\n\n                // U+0022 QUOTATION MARK (\")\n                // U+0027 APOSTROPHE (')\n                // U+0028 LEFT PARENTHESIS (()\n                // non-printable code point\n                case 0x0022:\n                case 0x0027:\n                case 0x0028:\n                case charCodeDefinitions.NonPrintableCategory:\n                    // This is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = utils.consumeBadUrlRemnants(source, offset);\n                    type = types.BadUrl;\n                    return;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the stream starts with a valid escape, consume an escaped code point and\n                    // append the returned code point to the <url-token>’s value.\n                    if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {\n                        offset = utils.consumeEscaped(source, offset) - 1;\n                        break;\n                    }\n\n                    // Otherwise, this is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = utils.consumeBadUrlRemnants(source, offset);\n                    type = types.BadUrl;\n                    return;\n\n                // anything else\n                // Append the current input code point to the <url-token>’s value.\n            }\n        }\n    }\n\n    // ensure source is a string\n    source = String(source || '');\n\n    const sourceLength = source.length;\n    let start = charCodeDefinitions.isBOM(getCharCode(0));\n    let offset = start;\n    let type;\n\n    // https://drafts.csswg.org/css-syntax-3/#consume-token\n    // § 4.3.1. Consume a token\n    while (offset < sourceLength) {\n        const code = source.charCodeAt(offset);\n\n        switch (charCodeDefinitions.charCodeCategory(code)) {\n            // whitespace\n            case charCodeDefinitions.WhiteSpaceCategory:\n                // Consume as much whitespace as possible. Return a <whitespace-token>.\n                type = types.WhiteSpace;\n                offset = utils.findWhiteSpaceEnd(source, offset + 1);\n                break;\n\n            // U+0022 QUOTATION MARK (\")\n            case 0x0022:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0023 NUMBER SIGN (#)\n            case 0x0023:\n                // If the next input code point is a name code point or the next two input code points are a valid escape, then:\n                if (charCodeDefinitions.isName(getCharCode(offset + 1)) || charCodeDefinitions.isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // Create a <hash-token>.\n                    type = types.Hash;\n\n                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to \"id\".\n                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    //     // TODO: set id flag\n                    // }\n\n                    // Consume a name, and set the <hash-token>’s value to the returned string.\n                    offset = utils.consumeName(source, offset + 1);\n\n                    // Return the <hash-token>.\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = types.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0027 APOSTROPHE (')\n            case 0x0027:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0028 LEFT PARENTHESIS (()\n            case 0x0028:\n                // Return a <(-token>.\n                type = types.LeftParenthesis;\n                offset++;\n                break;\n\n            // U+0029 RIGHT PARENTHESIS ())\n            case 0x0029:\n                // Return a <)-token>.\n                type = types.RightParenthesis;\n                offset++;\n                break;\n\n            // U+002B PLUS SIGN (+)\n            case 0x002B:\n                // If the input stream starts with a number, ...\n                if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = types.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+002C COMMA (,)\n            case 0x002C:\n                // Return a <comma-token>.\n                type = types.Comma;\n                offset++;\n                break;\n\n            // U+002D HYPHEN-MINUS (-)\n            case 0x002D:\n                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n                if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.\n                    if (getCharCode(offset + 1) === 0x002D &&\n                        getCharCode(offset + 2) === 0x003E) {\n                        type = types.CDC;\n                        offset = offset + 3;\n                    } else {\n                        // Otherwise, if the input stream starts with an identifier, ...\n                        if (charCodeDefinitions.isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                            // ... reconsume the current input code point, consume an ident-like token, and return it.\n                            consumeIdentLikeToken();\n                        } else {\n                            // Otherwise, return a <delim-token> with its value set to the current input code point.\n                            type = types.Delim;\n                            offset++;\n                        }\n                    }\n                }\n                break;\n\n            // U+002E FULL STOP (.)\n            case 0x002E:\n                // If the input stream starts with a number, ...\n                if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = types.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+002F SOLIDUS (/)\n            case 0x002F:\n                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),\n                if (getCharCode(offset + 1) === 0x002A) {\n                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)\n                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.\n                    type = types.Comment;\n                    offset = source.indexOf('*/', offset + 2);\n                    offset = offset === -1 ? source.length : offset + 2;\n                } else {\n                    type = types.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+003A COLON (:)\n            case 0x003A:\n                // Return a <colon-token>.\n                type = types.Colon;\n                offset++;\n                break;\n\n            // U+003B SEMICOLON (;)\n            case 0x003B:\n                // Return a <semicolon-token>.\n                type = types.Semicolon;\n                offset++;\n                break;\n\n            // U+003C LESS-THAN SIGN (<)\n            case 0x003C:\n                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...\n                if (getCharCode(offset + 1) === 0x0021 &&\n                    getCharCode(offset + 2) === 0x002D &&\n                    getCharCode(offset + 3) === 0x002D) {\n                    // ... consume them and return a <CDO-token>.\n                    type = types.CDO;\n                    offset = offset + 4;\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = types.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0040 COMMERCIAL AT (@)\n            case 0x0040:\n                // If the next 3 input code points would start an identifier, ...\n                if (charCodeDefinitions.isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.\n                    type = types.AtKeyword;\n                    offset = utils.consumeName(source, offset + 1);\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = types.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+005B LEFT SQUARE BRACKET ([)\n            case 0x005B:\n                // Return a <[-token>.\n                type = types.LeftSquareBracket;\n                offset++;\n                break;\n\n            // U+005C REVERSE SOLIDUS (\\)\n            case 0x005C:\n                // If the input stream starts with a valid escape, ...\n                if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {\n                    // ... reconsume the current input code point, consume an ident-like token, and return it.\n                    consumeIdentLikeToken();\n                } else {\n                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n                    type = types.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+005D RIGHT SQUARE BRACKET (])\n            case 0x005D:\n                // Return a <]-token>.\n                type = types.RightSquareBracket;\n                offset++;\n                break;\n\n            // U+007B LEFT CURLY BRACKET ({)\n            case 0x007B:\n                // Return a <{-token>.\n                type = types.LeftCurlyBracket;\n                offset++;\n                break;\n\n            // U+007D RIGHT CURLY BRACKET (})\n            case 0x007D:\n                // Return a <}-token>.\n                type = types.RightCurlyBracket;\n                offset++;\n                break;\n\n            // digit\n            case charCodeDefinitions.DigitCategory:\n                // Reconsume the current input code point, consume a numeric token, and return it.\n                consumeNumericToken();\n                break;\n\n            // name-start code point\n            case charCodeDefinitions.NameStartCategory:\n                // Reconsume the current input code point, consume an ident-like token, and return it.\n                consumeIdentLikeToken();\n                break;\n\n                // EOF\n                // case EofCategory:\n                // Return an <EOF-token>.\n                // break;\n\n            // anything else\n            default:\n                // Return a <delim-token> with its value set to the current input code point.\n                type = types.Delim;\n                offset++;\n        }\n\n        // put token to stream\n        onToken(type, start, start = offset);\n    }\n}\n\nexports.AtKeyword = types.AtKeyword;\nexports.BadString = types.BadString;\nexports.BadUrl = types.BadUrl;\nexports.CDC = types.CDC;\nexports.CDO = types.CDO;\nexports.Colon = types.Colon;\nexports.Comma = types.Comma;\nexports.Comment = types.Comment;\nexports.Delim = types.Delim;\nexports.Dimension = types.Dimension;\nexports.EOF = types.EOF;\nexports.Function = types.Function;\nexports.Hash = types.Hash;\nexports.Ident = types.Ident;\nexports.LeftCurlyBracket = types.LeftCurlyBracket;\nexports.LeftParenthesis = types.LeftParenthesis;\nexports.LeftSquareBracket = types.LeftSquareBracket;\nexports.Number = types.Number;\nexports.Percentage = types.Percentage;\nexports.RightCurlyBracket = types.RightCurlyBracket;\nexports.RightParenthesis = types.RightParenthesis;\nexports.RightSquareBracket = types.RightSquareBracket;\nexports.Semicolon = types.Semicolon;\nexports.String = types.String;\nexports.Url = types.Url;\nexports.WhiteSpace = types.WhiteSpace;\nexports.tokenTypes = types;\nexports.DigitCategory = charCodeDefinitions.DigitCategory;\nexports.EofCategory = charCodeDefinitions.EofCategory;\nexports.NameStartCategory = charCodeDefinitions.NameStartCategory;\nexports.NonPrintableCategory = charCodeDefinitions.NonPrintableCategory;\nexports.WhiteSpaceCategory = charCodeDefinitions.WhiteSpaceCategory;\nexports.charCodeCategory = charCodeDefinitions.charCodeCategory;\nexports.isBOM = charCodeDefinitions.isBOM;\nexports.isDigit = charCodeDefinitions.isDigit;\nexports.isHexDigit = charCodeDefinitions.isHexDigit;\nexports.isIdentifierStart = charCodeDefinitions.isIdentifierStart;\nexports.isLetter = charCodeDefinitions.isLetter;\nexports.isLowercaseLetter = charCodeDefinitions.isLowercaseLetter;\nexports.isName = charCodeDefinitions.isName;\nexports.isNameStart = charCodeDefinitions.isNameStart;\nexports.isNewline = charCodeDefinitions.isNewline;\nexports.isNonAscii = charCodeDefinitions.isNonAscii;\nexports.isNonPrintable = charCodeDefinitions.isNonPrintable;\nexports.isNumberStart = charCodeDefinitions.isNumberStart;\nexports.isUppercaseLetter = charCodeDefinitions.isUppercaseLetter;\nexports.isValidEscape = charCodeDefinitions.isValidEscape;\nexports.isWhiteSpace = charCodeDefinitions.isWhiteSpace;\nexports.cmpChar = utils.cmpChar;\nexports.cmpStr = utils.cmpStr;\nexports.consumeBadUrlRemnants = utils.consumeBadUrlRemnants;\nexports.consumeEscaped = utils.consumeEscaped;\nexports.consumeName = utils.consumeName;\nexports.consumeNumber = utils.consumeNumber;\nexports.decodeEscaped = utils.decodeEscaped;\nexports.findDecimalNumberEnd = utils.findDecimalNumberEnd;\nexports.findWhiteSpaceEnd = utils.findWhiteSpaceEnd;\nexports.findWhiteSpaceStart = utils.findWhiteSpaceStart;\nexports.getNewlineLength = utils.getNewlineLength;\nexports.tokenNames = names;\nexports.OffsetToLocation = OffsetToLocation.OffsetToLocation;\nexports.TokenStream = TokenStream.TokenStream;\nexports.tokenize = tokenize;\n","'use strict';\n\n//\n//                              list\n//                            ┌──────┐\n//             ┌──────────────┼─head │\n//             │              │ tail─┼──────────────┐\n//             │              └──────┘              │\n//             ▼                                    ▼\n//            item        item        item        item\n//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐\n//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │\n//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null\n//          ├──────┤    ├──────┤    ├──────┤    ├──────┤\n//          │ data │    │ data │    │ data │    │ data │\n//          └──────┘    └──────┘    └──────┘    └──────┘\n//\n\nlet releasedCursors = null;\n\nclass List {\n    static createItem(data) {\n        return {\n            prev: null,\n            next: null,\n            data\n        };\n    }\n\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.cursor = null;\n    }\n    createItem(data) {\n        return List.createItem(data);\n    }\n\n    // cursor helpers\n    allocateCursor(prev, next) {\n        let cursor;\n\n        if (releasedCursors !== null) {\n            cursor = releasedCursors;\n            releasedCursors = releasedCursors.cursor;\n            cursor.prev = prev;\n            cursor.next = next;\n            cursor.cursor = this.cursor;\n        } else {\n            cursor = {\n                prev,\n                next,\n                cursor: this.cursor\n            };\n        }\n\n        this.cursor = cursor;\n\n        return cursor;\n    }\n    releaseCursor() {\n        const { cursor } = this;\n\n        this.cursor = cursor.cursor;\n        cursor.prev = null;\n        cursor.next = null;\n        cursor.cursor = releasedCursors;\n        releasedCursors = cursor;\n    }\n    updateCursors(prevOld, prevNew, nextOld, nextNew) {\n        let { cursor } = this;\n\n        while (cursor !== null) {\n            if (cursor.prev === prevOld) {\n                cursor.prev = prevNew;\n            }\n\n            if (cursor.next === nextOld) {\n                cursor.next = nextNew;\n            }\n\n            cursor = cursor.cursor;\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            yield cursor.data;\n        }\n    }\n\n    // getters\n    get size() {\n        let size = 0;\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            size++;\n        }\n\n        return size;\n    }\n    get isEmpty() {\n        return this.head === null;\n    }\n    get first() {\n        return this.head && this.head.data;\n    }\n    get last() {\n        return this.tail && this.tail.data;\n    }\n\n    // convertors\n    fromArray(array) {\n        let cursor = null;\n        this.head = null;\n\n        for (let data of array) {\n            const item = List.createItem(data);\n\n            if (cursor !== null) {\n                cursor.next = item;\n            } else {\n                this.head = item;\n            }\n\n            item.prev = cursor;\n            cursor = item;\n        }\n\n        this.tail = cursor;\n        return this;\n    }\n    toArray() {\n        return [...this];\n    }\n    toJSON() {\n        return [...this];\n    }\n\n    // array-like methods\n    forEach(fn, thisArg = this) {\n        // push cursor\n        const cursor = this.allocateCursor(null, this.head);\n\n        while (cursor.next !== null) {\n            const item = cursor.next;\n            cursor.next = item.next;\n            fn.call(thisArg, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    forEachRight(fn, thisArg = this) {\n        // push cursor\n        const cursor = this.allocateCursor(this.tail, null);\n\n        while (cursor.prev !== null) {\n            const item = cursor.prev;\n            cursor.prev = item.prev;\n            fn.call(thisArg, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    reduce(fn, initialValue, thisArg = this) {\n        // push cursor\n        let cursor = this.allocateCursor(null, this.head);\n        let acc = initialValue;\n        let item;\n\n        while (cursor.next !== null) {\n            item = cursor.next;\n            cursor.next = item.next;\n\n            acc = fn.call(thisArg, acc, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n\n        return acc;\n    }\n    reduceRight(fn, initialValue, thisArg = this) {\n        // push cursor\n        let cursor = this.allocateCursor(this.tail, null);\n        let acc = initialValue;\n        let item;\n\n        while (cursor.prev !== null) {\n            item = cursor.prev;\n            cursor.prev = item.prev;\n\n            acc = fn.call(thisArg, acc, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n\n        return acc;\n    }\n    some(fn, thisArg = this) {\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            if (fn.call(thisArg, cursor.data, cursor, this)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n    map(fn, thisArg = this) {\n        const result = new List();\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            result.appendData(fn.call(thisArg, cursor.data, cursor, this));\n        }\n\n        return result;\n    }\n    filter(fn, thisArg = this) {\n        const result = new List();\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            if (fn.call(thisArg, cursor.data, cursor, this)) {\n                result.appendData(cursor.data);\n            }\n        }\n\n        return result;\n    }\n\n    nextUntil(start, fn, thisArg = this) {\n        if (start === null) {\n            return;\n        }\n\n        // push cursor\n        const cursor = this.allocateCursor(null, start);\n\n        while (cursor.next !== null) {\n            const item = cursor.next;\n            cursor.next = item.next;\n            if (fn.call(thisArg, item.data, item, this)) {\n                break;\n            }\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    prevUntil(start, fn, thisArg = this) {\n        if (start === null) {\n            return;\n        }\n\n        // push cursor\n        const cursor = this.allocateCursor(start, null);\n\n        while (cursor.prev !== null) {\n            const item = cursor.prev;\n            cursor.prev = item.prev;\n            if (fn.call(thisArg, item.data, item, this)) {\n                break;\n            }\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n\n    // mutation\n    clear() {\n        this.head = null;\n        this.tail = null;\n    }\n    copy() {\n        const result = new List();\n\n        for (let data of this) {\n            result.appendData(data);\n        }\n\n        return result;\n    }\n    prepend(item) {\n        //      head\n        //    ^\n        // item\n        this.updateCursors(null, item, this.head, item);\n\n        // insert to the beginning of the list\n        if (this.head !== null) {\n            // new item <- first item\n            this.head.prev = item;\n            // new item -> first item\n            item.next = this.head;\n        } else {\n            // if list has no head, then it also has no tail\n            // in this case tail points to the new item\n            this.tail = item;\n        }\n\n        // head always points to new item\n        this.head = item;\n        return this;\n    }\n    prependData(data) {\n        return this.prepend(List.createItem(data));\n    }\n    append(item) {\n        return this.insert(item);\n    }\n    appendData(data) {\n        return this.insert(List.createItem(data));\n    }\n    insert(item, before = null) {\n        if (before !== null) {\n            // prev   before\n            //      ^\n            //     item\n            this.updateCursors(before.prev, item, before, item);\n\n            if (before.prev === null) {\n                // insert to the beginning of list\n                if (this.head !== before) {\n                    throw new Error('before doesn\\'t belong to list');\n                }\n                // since head points to before therefore list doesn't empty\n                // no need to check tail\n                this.head = item;\n                before.prev = item;\n                item.next = before;\n                this.updateCursors(null, item);\n            } else {\n                // insert between two items\n                before.prev.next = item;\n                item.prev = before.prev;\n                before.prev = item;\n                item.next = before;\n            }\n        } else {\n            // tail\n            //      ^\n            //      item\n            this.updateCursors(this.tail, item, null, item);\n\n            // insert to the ending of the list\n            if (this.tail !== null) {\n                // last item -> new item\n                this.tail.next = item;\n                // last item <- new item\n                item.prev = this.tail;\n            } else {\n                // if list has no tail, then it also has no head\n                // in this case head points to new item\n                this.head = item;\n            }\n\n            // tail always points to new item\n            this.tail = item;\n        }\n\n        return this;\n    }\n    insertData(data, before) {\n        return this.insert(List.createItem(data), before);\n    }\n    remove(item) {\n        //      item\n        //       ^\n        // prev     next\n        this.updateCursors(item, item.prev, item, item.next);\n\n        if (item.prev !== null) {\n            item.prev.next = item.next;\n        } else {\n            if (this.head !== item) {\n                throw new Error('item doesn\\'t belong to list');\n            }\n\n            this.head = item.next;\n        }\n\n        if (item.next !== null) {\n            item.next.prev = item.prev;\n        } else {\n            if (this.tail !== item) {\n                throw new Error('item doesn\\'t belong to list');\n            }\n\n            this.tail = item.prev;\n        }\n\n        item.prev = null;\n        item.next = null;\n\n        return item;\n    }\n    push(data) {\n        this.insert(List.createItem(data));\n    }\n    pop() {\n        return this.tail !== null ? this.remove(this.tail) : null;\n    }\n    unshift(data) {\n        this.prepend(List.createItem(data));\n    }\n    shift() {\n        return this.head !== null ? this.remove(this.head) : null;\n    }\n    prependList(list) {\n        return this.insertList(list, this.head);\n    }\n    appendList(list) {\n        return this.insertList(list);\n    }\n    insertList(list, before) {\n        // ignore empty lists\n        if (list.head === null) {\n            return this;\n        }\n\n        if (before !== undefined && before !== null) {\n            this.updateCursors(before.prev, list.tail, before, list.head);\n\n            // insert in the middle of dist list\n            if (before.prev !== null) {\n                // before.prev <-> list.head\n                before.prev.next = list.head;\n                list.head.prev = before.prev;\n            } else {\n                this.head = list.head;\n            }\n\n            before.prev = list.tail;\n            list.tail.next = before;\n        } else {\n            this.updateCursors(this.tail, list.tail, null, list.head);\n\n            // insert to end of the list\n            if (this.tail !== null) {\n                // if destination list has a tail, then it also has a head,\n                // but head doesn't change\n                // dest tail -> source head\n                this.tail.next = list.head;\n                // dest tail <- source head\n                list.head.prev = this.tail;\n            } else {\n                // if list has no a tail, then it also has no a head\n                // in this case points head to new item\n                this.head = list.head;\n            }\n\n            // tail always start point to new item\n            this.tail = list.tail;\n        }\n\n        list.head = null;\n        list.tail = null;\n        return this;\n    }\n    replace(oldItem, newItemOrList) {\n        if ('head' in newItemOrList) {\n            this.insertList(newItemOrList, oldItem);\n        } else {\n            this.insert(newItemOrList, oldItem);\n        }\n\n        this.remove(oldItem);\n    }\n}\n\nexports.List = List;\n","'use strict';\n\nfunction createCustomError(name, message) {\n    // use Object.create(), because some VMs prevent setting line/column otherwise\n    // (iOS Safari 10 even throws an exception)\n    const error = Object.create(SyntaxError.prototype);\n    const errorStack = new Error();\n\n    return Object.assign(error, {\n        name,\n        message,\n        get stack() {\n            return (errorStack.stack || '').replace(/^(.+\\n){1,3}/, `${name}: ${message}\\n`);\n        }\n    });\n}\n\nexports.createCustomError = createCustomError;\n","'use strict';\n\nconst createCustomError = require('../utils/create-custom-error.cjs');\n\nconst MAX_LINE_LENGTH = 100;\nconst OFFSET_CORRECTION = 60;\nconst TAB_REPLACEMENT = '    ';\n\nfunction sourceFragment({ source, line, column }, extraLines) {\n    function processLines(start, end) {\n        return lines\n            .slice(start, end)\n            .map((line, idx) =>\n                String(start + idx + 1).padStart(maxNumLength) + ' |' + line\n            ).join('\\n');\n    }\n\n    const lines = source.split(/\\r\\n?|\\n|\\f/);\n    const startLine = Math.max(1, line - extraLines) - 1;\n    const endLine = Math.min(line + extraLines, lines.length + 1);\n    const maxNumLength = Math.max(4, String(endLine).length) + 1;\n    let cutLeft = 0;\n\n    // column correction according to replaced tab before column\n    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\\t/g) || []).length;\n\n    if (column > MAX_LINE_LENGTH) {\n        cutLeft = column - OFFSET_CORRECTION + 3;\n        column = OFFSET_CORRECTION - 2;\n    }\n\n    for (let i = startLine; i <= endLine; i++) {\n        if (i >= 0 && i < lines.length) {\n            lines[i] = lines[i].replace(/\\t/g, TAB_REPLACEMENT);\n            lines[i] =\n                (cutLeft > 0 && lines[i].length > cutLeft ? '\\u2026' : '') +\n                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +\n                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\\u2026' : '');\n        }\n    }\n\n    return [\n        processLines(startLine, line),\n        new Array(column + maxNumLength + 2).join('-') + '^',\n        processLines(line, endLine)\n    ].filter(Boolean).join('\\n');\n}\n\nfunction SyntaxError(message, source, offset, line, column) {\n    const error = Object.assign(createCustomError.createCustomError('SyntaxError', message), {\n        source,\n        offset,\n        line,\n        column,\n        sourceFragment(extraLines) {\n            return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);\n        },\n        get formattedMessage() {\n            return (\n                `Parse error: ${message}\\n` +\n                sourceFragment({ source, line, column }, 2)\n            );\n        }\n    });\n\n    return error;\n}\n\nexports.SyntaxError = SyntaxError;\n","'use strict';\n\nconst types = require('../tokenizer/types.cjs');\n\nfunction readSequence(recognizer) {\n    const children = this.createList();\n    let space = false;\n    const context = {\n        recognizer\n    };\n\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case types.Comment:\n                this.next();\n                continue;\n\n            case types.WhiteSpace:\n                space = true;\n                this.next();\n                continue;\n        }\n\n        let child = recognizer.getNode.call(this, context);\n\n        if (child === undefined) {\n            break;\n        }\n\n        if (space) {\n            if (recognizer.onWhiteSpace) {\n                recognizer.onWhiteSpace.call(this, child, children, context);\n            }\n            space = false;\n        }\n\n        children.push(child);\n    }\n\n    if (space && recognizer.onWhiteSpace) {\n        recognizer.onWhiteSpace.call(this, null, children, context);\n    }\n\n    return children;\n}\n\nexports.readSequence = readSequence;\n","'use strict';\n\nconst List = require('../utils/List.cjs');\nconst SyntaxError = require('./SyntaxError.cjs');\nconst index = require('../tokenizer/index.cjs');\nconst sequence = require('./sequence.cjs');\nconst OffsetToLocation = require('../tokenizer/OffsetToLocation.cjs');\nconst TokenStream = require('../tokenizer/TokenStream.cjs');\nconst utils = require('../tokenizer/utils.cjs');\nconst types = require('../tokenizer/types.cjs');\nconst names = require('../tokenizer/names.cjs');\n\nconst NOOP = () => {};\nconst EXCLAMATIONMARK = 0x0021;  // U+0021 EXCLAMATION MARK (!)\nconst NUMBERSIGN = 0x0023;       // U+0023 NUMBER SIGN (#)\nconst SEMICOLON = 0x003B;        // U+003B SEMICOLON (;)\nconst LEFTCURLYBRACKET = 0x007B; // U+007B LEFT CURLY BRACKET ({)\nconst NULL = 0;\n\nfunction createParseContext(name) {\n    return function() {\n        return this[name]();\n    };\n}\n\nfunction fetchParseValues(dict) {\n    const result = Object.create(null);\n\n    for (const name in dict) {\n        const item = dict[name];\n        const fn = item.parse || item;\n\n        if (fn) {\n            result[name] = fn;\n        }\n    }\n\n    return result;\n}\n\nfunction processConfig(config) {\n    const parseConfig = {\n        context: Object.create(null),\n        scope: Object.assign(Object.create(null), config.scope),\n        atrule: fetchParseValues(config.atrule),\n        pseudo: fetchParseValues(config.pseudo),\n        node: fetchParseValues(config.node)\n    };\n\n    for (const name in config.parseContext) {\n        switch (typeof config.parseContext[name]) {\n            case 'function':\n                parseConfig.context[name] = config.parseContext[name];\n                break;\n\n            case 'string':\n                parseConfig.context[name] = createParseContext(config.parseContext[name]);\n                break;\n        }\n    }\n\n    return {\n        config: parseConfig,\n        ...parseConfig,\n        ...parseConfig.node\n    };\n}\n\nfunction createParser(config) {\n    let source = '';\n    let filename = '<unknown>';\n    let needPositions = false;\n    let onParseError = NOOP;\n    let onParseErrorThrow = false;\n\n    const locationMap = new OffsetToLocation.OffsetToLocation();\n    const parser = Object.assign(new TokenStream.TokenStream(), processConfig(config || {}), {\n        parseAtrulePrelude: true,\n        parseRulePrelude: true,\n        parseValue: true,\n        parseCustomProperty: false,\n\n        readSequence: sequence.readSequence,\n\n        consumeUntilBalanceEnd: () => 0,\n        consumeUntilLeftCurlyBracket(code) {\n            return code === LEFTCURLYBRACKET ? 1 : 0;\n        },\n        consumeUntilLeftCurlyBracketOrSemicolon(code) {\n            return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;\n        },\n        consumeUntilExclamationMarkOrSemicolon(code) {\n            return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;\n        },\n        consumeUntilSemicolonIncluded(code) {\n            return code === SEMICOLON ? 2 : 0;\n        },\n\n        createList() {\n            return new List.List();\n        },\n        createSingleNodeList(node) {\n            return new List.List().appendData(node);\n        },\n        getFirstListNode(list) {\n            return list && list.first;\n        },\n        getLastListNode(list) {\n            return list && list.last;\n        },\n\n        parseWithFallback(consumer, fallback) {\n            const startToken = this.tokenIndex;\n\n            try {\n                return consumer.call(this);\n            } catch (e) {\n                if (onParseErrorThrow) {\n                    throw e;\n                }\n\n                const fallbackNode = fallback.call(this, startToken);\n\n                onParseErrorThrow = true;\n                onParseError(e, fallbackNode);\n                onParseErrorThrow = false;\n\n                return fallbackNode;\n            }\n        },\n\n        lookupNonWSType(offset) {\n            let type;\n\n            do {\n                type = this.lookupType(offset++);\n                if (type !== types.WhiteSpace) {\n                    return type;\n                }\n            } while (type !== NULL);\n\n            return NULL;\n        },\n\n        charCodeAt(offset) {\n            return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;\n        },\n        substring(offsetStart, offsetEnd) {\n            return source.substring(offsetStart, offsetEnd);\n        },\n        substrToCursor(start) {\n            return this.source.substring(start, this.tokenStart);\n        },\n\n        cmpChar(offset, charCode) {\n            return utils.cmpChar(source, offset, charCode);\n        },\n        cmpStr(offsetStart, offsetEnd, str) {\n            return utils.cmpStr(source, offsetStart, offsetEnd, str);\n        },\n\n        consume(tokenType) {\n            const start = this.tokenStart;\n\n            this.eat(tokenType);\n\n            return this.substrToCursor(start);\n        },\n        consumeFunctionName() {\n            const name = source.substring(this.tokenStart, this.tokenEnd - 1);\n\n            this.eat(types.Function);\n\n            return name;\n        },\n        consumeNumber(type) {\n            const number = source.substring(this.tokenStart, utils.consumeNumber(source, this.tokenStart));\n\n            this.eat(type);\n\n            return number;\n        },\n\n        eat(tokenType) {\n            if (this.tokenType !== tokenType) {\n                const tokenName = names[tokenType].slice(0, -6).replace(/-/g, ' ').replace(/^./, m => m.toUpperCase());\n                let message = `${/[[\\](){}]/.test(tokenName) ? `\"${tokenName}\"` : tokenName} is expected`;\n                let offset = this.tokenStart;\n\n                // tweak message and offset\n                switch (tokenType) {\n                    case types.Ident:\n                        // when identifier is expected but there is a function or url\n                        if (this.tokenType === types.Function || this.tokenType === types.Url) {\n                            offset = this.tokenEnd - 1;\n                            message = 'Identifier is expected but function found';\n                        } else {\n                            message = 'Identifier is expected';\n                        }\n                        break;\n\n                    case types.Hash:\n                        if (this.isDelim(NUMBERSIGN)) {\n                            this.next();\n                            offset++;\n                            message = 'Name is expected';\n                        }\n                        break;\n\n                    case types.Percentage:\n                        if (this.tokenType === types.Number) {\n                            offset = this.tokenEnd;\n                            message = 'Percent sign is expected';\n                        }\n                        break;\n                }\n\n                this.error(message, offset);\n            }\n\n            this.next();\n        },\n        eatIdent(name) {\n            if (this.tokenType !== types.Ident || this.lookupValue(0, name) === false) {\n                this.error(`Identifier \"${name}\" is expected`);\n            }\n\n            this.next();\n        },\n        eatDelim(code) {\n            if (!this.isDelim(code)) {\n                this.error(`Delim \"${String.fromCharCode(code)}\" is expected`);\n            }\n\n            this.next();\n        },\n\n        getLocation(start, end) {\n            if (needPositions) {\n                return locationMap.getLocationRange(\n                    start,\n                    end,\n                    filename\n                );\n            }\n\n            return null;\n        },\n        getLocationFromList(list) {\n            if (needPositions) {\n                const head = this.getFirstListNode(list);\n                const tail = this.getLastListNode(list);\n                return locationMap.getLocationRange(\n                    head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,\n                    tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,\n                    filename\n                );\n            }\n\n            return null;\n        },\n\n        error(message, offset) {\n            const location = typeof offset !== 'undefined' && offset < source.length\n                ? locationMap.getLocation(offset)\n                : this.eof\n                    ? locationMap.getLocation(utils.findWhiteSpaceStart(source, source.length - 1))\n                    : locationMap.getLocation(this.tokenStart);\n\n            throw new SyntaxError.SyntaxError(\n                message || 'Unexpected input',\n                source,\n                location.offset,\n                location.line,\n                location.column\n            );\n        }\n    });\n\n    const parse = function(source_, options) {\n        source = source_;\n        options = options || {};\n\n        parser.setSource(source, index.tokenize);\n        locationMap.setSource(\n            source,\n            options.offset,\n            options.line,\n            options.column\n        );\n\n        filename = options.filename || '<unknown>';\n        needPositions = Boolean(options.positions);\n        onParseError = typeof options.onParseError === 'function' ? options.onParseError : NOOP;\n        onParseErrorThrow = false;\n\n        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n        const { context = 'default', onComment } = options;\n\n        if (context in parser.context === false) {\n            throw new Error('Unknown context `' + context + '`');\n        }\n\n        if (typeof onComment === 'function') {\n            parser.forEachToken((type, start, end) => {\n                if (type === types.Comment) {\n                    const loc = parser.getLocation(start, end);\n                    const value = utils.cmpStr(source, end - 2, end, '*/')\n                        ? source.slice(start + 2, end - 2)\n                        : source.slice(start + 2, end);\n\n                    onComment(value, loc);\n                }\n            });\n        }\n\n        const ast = parser.context[context].call(parser, options);\n\n        if (!parser.eof) {\n            parser.error();\n        }\n\n        return ast;\n    };\n\n    return Object.assign(parse, {\n        SyntaxError: SyntaxError.SyntaxError,\n        config: parser.config\n    });\n}\n\nexports.createParser = createParser;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nvar MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  var cache = [];\n\n  return function(input) {\n    for (var i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        var temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    var result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nvar normalize = lruMemoize(function normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  var parts = [];\n  var start = 0;\n  var i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\nfunction compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   “sources” entry.  This value is prepended to the individual\n    //   entries in the “source” field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   “sourceRoot”, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n","'use strict';\n\nconst sourceMapGenerator_js = require('source-map-js/lib/source-map-generator.js');\n\nconst trackNodes = new Set(['Atrule', 'Selector', 'Declaration']);\n\nfunction generateSourceMap(handlers) {\n    const map = new sourceMapGenerator_js.SourceMapGenerator();\n    const generated = {\n        line: 1,\n        column: 0\n    };\n    const original = {\n        line: 0, // should be zero to add first mapping\n        column: 0\n    };\n    const activatedGenerated = {\n        line: 1,\n        column: 0\n    };\n    const activatedMapping = {\n        generated: activatedGenerated\n    };\n    let line = 1;\n    let column = 0;\n    let sourceMappingActive = false;\n\n    const origHandlersNode = handlers.node;\n    handlers.node = function(node) {\n        if (node.loc && node.loc.start && trackNodes.has(node.type)) {\n            const nodeLine = node.loc.start.line;\n            const nodeColumn = node.loc.start.column - 1;\n\n            if (original.line !== nodeLine ||\n                original.column !== nodeColumn) {\n                original.line = nodeLine;\n                original.column = nodeColumn;\n\n                generated.line = line;\n                generated.column = column;\n\n                if (sourceMappingActive) {\n                    sourceMappingActive = false;\n                    if (generated.line !== activatedGenerated.line ||\n                        generated.column !== activatedGenerated.column) {\n                        map.addMapping(activatedMapping);\n                    }\n                }\n\n                sourceMappingActive = true;\n                map.addMapping({\n                    source: node.loc.source,\n                    original,\n                    generated\n                });\n            }\n        }\n\n        origHandlersNode.call(this, node);\n\n        if (sourceMappingActive && trackNodes.has(node.type)) {\n            activatedGenerated.line = line;\n            activatedGenerated.column = column;\n        }\n    };\n\n    const origHandlersEmit = handlers.emit;\n    handlers.emit = function(value, type, auto) {\n        for (let i = 0; i < value.length; i++) {\n            if (value.charCodeAt(i) === 10) { // \\n\n                line++;\n                column = 0;\n            } else {\n                column++;\n            }\n        }\n\n        origHandlersEmit(value, type, auto);\n    };\n\n    const origHandlersResult = handlers.result;\n    handlers.result = function() {\n        if (sourceMappingActive) {\n            map.addMapping(activatedMapping);\n        }\n\n        return {\n            css: origHandlersResult(),\n            map\n        };\n    };\n\n    return handlers;\n}\n\nexports.generateSourceMap = generateSourceMap;\n","'use strict';\n\nconst types = require('../tokenizer/types.cjs');\n\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\n\nconst code = (type, value) => {\n    if (type === types.Delim) {\n        type = value;\n    }\n\n    if (typeof type === 'string') {\n        const charCode = type.charCodeAt(0);\n        return charCode > 0x7F ? 0x8000 : charCode << 8;\n    }\n\n    return type;\n};\n\n// https://www.w3.org/TR/css-syntax-3/#serialization\n// The only requirement for serialization is that it must \"round-trip\" with parsing,\n// that is, parsing the stylesheet must produce the same data structures as parsing,\n// serializing, and parsing again, except for consecutive <whitespace-token>s,\n// which may be collapsed into a single token.\n\nconst specPairs = [\n    [types.Ident, types.Ident],\n    [types.Ident, types.Function],\n    [types.Ident, types.Url],\n    [types.Ident, types.BadUrl],\n    [types.Ident, '-'],\n    [types.Ident, types.Number],\n    [types.Ident, types.Percentage],\n    [types.Ident, types.Dimension],\n    [types.Ident, types.CDC],\n    [types.Ident, types.LeftParenthesis],\n\n    [types.AtKeyword, types.Ident],\n    [types.AtKeyword, types.Function],\n    [types.AtKeyword, types.Url],\n    [types.AtKeyword, types.BadUrl],\n    [types.AtKeyword, '-'],\n    [types.AtKeyword, types.Number],\n    [types.AtKeyword, types.Percentage],\n    [types.AtKeyword, types.Dimension],\n    [types.AtKeyword, types.CDC],\n\n    [types.Hash, types.Ident],\n    [types.Hash, types.Function],\n    [types.Hash, types.Url],\n    [types.Hash, types.BadUrl],\n    [types.Hash, '-'],\n    [types.Hash, types.Number],\n    [types.Hash, types.Percentage],\n    [types.Hash, types.Dimension],\n    [types.Hash, types.CDC],\n\n    [types.Dimension, types.Ident],\n    [types.Dimension, types.Function],\n    [types.Dimension, types.Url],\n    [types.Dimension, types.BadUrl],\n    [types.Dimension, '-'],\n    [types.Dimension, types.Number],\n    [types.Dimension, types.Percentage],\n    [types.Dimension, types.Dimension],\n    [types.Dimension, types.CDC],\n\n    ['#', types.Ident],\n    ['#', types.Function],\n    ['#', types.Url],\n    ['#', types.BadUrl],\n    ['#', '-'],\n    ['#', types.Number],\n    ['#', types.Percentage],\n    ['#', types.Dimension],\n    ['#', types.CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['-', types.Ident],\n    ['-', types.Function],\n    ['-', types.Url],\n    ['-', types.BadUrl],\n    ['-', '-'],\n    ['-', types.Number],\n    ['-', types.Percentage],\n    ['-', types.Dimension],\n    ['-', types.CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    [types.Number, types.Ident],\n    [types.Number, types.Function],\n    [types.Number, types.Url],\n    [types.Number, types.BadUrl],\n    [types.Number, types.Number],\n    [types.Number, types.Percentage],\n    [types.Number, types.Dimension],\n    [types.Number, '%'],\n    [types.Number, types.CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['@', types.Ident],\n    ['@', types.Function],\n    ['@', types.Url],\n    ['@', types.BadUrl],\n    ['@', '-'],\n    ['@', types.CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['.', types.Number],\n    ['.', types.Percentage],\n    ['.', types.Dimension],\n\n    ['+', types.Number],\n    ['+', types.Percentage],\n    ['+', types.Dimension],\n\n    ['/', '*']\n];\n// validate with scripts/generate-safe\nconst safePairs = specPairs.concat([\n    [types.Ident, types.Hash],\n\n    [types.Dimension, types.Hash],\n\n    [types.Hash, types.Hash],\n\n    [types.AtKeyword, types.LeftParenthesis],\n    [types.AtKeyword, types.String],\n    [types.AtKeyword, types.Colon],\n\n    [types.Percentage, types.Percentage],\n    [types.Percentage, types.Dimension],\n    [types.Percentage, types.Function],\n    [types.Percentage, '-'],\n\n    [types.RightParenthesis, types.Ident],\n    [types.RightParenthesis, types.Function],\n    [types.RightParenthesis, types.Percentage],\n    [types.RightParenthesis, types.Dimension],\n    [types.RightParenthesis, types.Hash],\n    [types.RightParenthesis, '-']\n]);\n\nfunction createMap(pairs) {\n    const isWhiteSpaceRequired = new Set(\n        pairs.map(([prev, next]) => (code(prev) << 16 | code(next)))\n    );\n\n    return function(prevCode, type, value) {\n        const nextCode = code(type, value);\n        const nextCharCode = value.charCodeAt(0);\n        const emitWs =\n            (nextCharCode === HYPHENMINUS &&\n                type !== types.Ident &&\n                type !== types.Function &&\n                type !== types.CDC) ||\n            (nextCharCode === PLUSSIGN)\n                ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8)\n                : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);\n\n        if (emitWs) {\n            this.emit(' ', types.WhiteSpace, true);\n        }\n\n        return nextCode;\n    };\n}\n\nconst spec = createMap(specPairs);\nconst safe = createMap(safePairs);\n\nexports.safe = safe;\nexports.spec = spec;\n","'use strict';\n\nconst index = require('../tokenizer/index.cjs');\nconst sourceMap = require('./sourceMap.cjs');\nconst tokenBefore = require('./token-before.cjs');\nconst types = require('../tokenizer/types.cjs');\n\nconst REVERSESOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\n\nfunction processChildren(node, delimeter) {\n    if (typeof delimeter === 'function') {\n        let prev = null;\n\n        node.children.forEach(node => {\n            if (prev !== null) {\n                delimeter.call(this, prev);\n            }\n\n            this.node(node);\n            prev = node;\n        });\n\n        return;\n    }\n\n    node.children.forEach(this.node, this);\n}\n\nfunction processChunk(chunk) {\n    index.tokenize(chunk, (type, start, end) => {\n        this.token(type, chunk.slice(start, end));\n    });\n}\n\nfunction createGenerator(config) {\n    const types$1 = new Map();\n\n    for (let name in config.node) {\n        const item = config.node[name];\n        const fn = item.generate || item;\n\n        if (typeof fn === 'function') {\n            types$1.set(name, item.generate || item);\n        }\n    }\n\n    return function(node, options) {\n        let buffer = '';\n        let prevCode = 0;\n        let handlers = {\n            node(node) {\n                if (types$1.has(node.type)) {\n                    types$1.get(node.type).call(publicApi, node);\n                } else {\n                    throw new Error('Unknown node type: ' + node.type);\n                }\n            },\n            tokenBefore: tokenBefore.safe,\n            token(type, value) {\n                prevCode = this.tokenBefore(prevCode, type, value);\n\n                this.emit(value, type, false);\n\n                if (type === types.Delim && value.charCodeAt(0) === REVERSESOLIDUS) {\n                    this.emit('\\n', types.WhiteSpace, true);\n                }\n            },\n            emit(value) {\n                buffer += value;\n            },\n            result() {\n                return buffer;\n            }\n        };\n\n        if (options) {\n            if (typeof options.decorator === 'function') {\n                handlers = options.decorator(handlers);\n            }\n\n            if (options.sourceMap) {\n                handlers = sourceMap.generateSourceMap(handlers);\n            }\n\n            if (options.mode in tokenBefore) {\n                handlers.tokenBefore = tokenBefore[options.mode];\n            }\n        }\n\n        const publicApi = {\n            node: (node) => handlers.node(node),\n            children: processChildren,\n            token: (type, value) => handlers.token(type, value),\n            tokenize: processChunk\n        };\n\n        handlers.node(node);\n\n        return handlers.result();\n    };\n}\n\nexports.createGenerator = createGenerator;\n","'use strict';\n\nconst List = require('../utils/List.cjs');\n\nfunction createConvertor(walk) {\n    return {\n        fromPlainObject(ast) {\n            walk(ast, {\n                enter(node) {\n                    if (node.children && node.children instanceof List.List === false) {\n                        node.children = new List.List().fromArray(node.children);\n                    }\n                }\n            });\n\n            return ast;\n        },\n        toPlainObject(ast) {\n            walk(ast, {\n                leave(node) {\n                    if (node.children && node.children instanceof List.List) {\n                        node.children = node.children.toArray();\n                    }\n                }\n            });\n\n            return ast;\n        }\n    };\n}\n\nexports.createConvertor = createConvertor;\n","'use strict';\n\nconst { hasOwnProperty } = Object.prototype;\nconst noop = function() {};\n\nfunction ensureFunction(value) {\n    return typeof value === 'function' ? value : noop;\n}\n\nfunction invokeForType(fn, type) {\n    return function(node, item, list) {\n        if (node.type === type) {\n            fn.call(this, node, item, list);\n        }\n    };\n}\n\nfunction getWalkersFromStructure(name, nodeType) {\n    const structure = nodeType.structure;\n    const walkers = [];\n\n    for (const key in structure) {\n        if (hasOwnProperty.call(structure, key) === false) {\n            continue;\n        }\n\n        let fieldTypes = structure[key];\n        const walker = {\n            name: key,\n            type: false,\n            nullable: false\n        };\n\n        if (!Array.isArray(fieldTypes)) {\n            fieldTypes = [fieldTypes];\n        }\n\n        for (const fieldType of fieldTypes) {\n            if (fieldType === null) {\n                walker.nullable = true;\n            } else if (typeof fieldType === 'string') {\n                walker.type = 'node';\n            } else if (Array.isArray(fieldType)) {\n                walker.type = 'list';\n            }\n        }\n\n        if (walker.type) {\n            walkers.push(walker);\n        }\n    }\n\n    if (walkers.length) {\n        return {\n            context: nodeType.walkContext,\n            fields: walkers\n        };\n    }\n\n    return null;\n}\n\nfunction getTypesFromConfig(config) {\n    const types = {};\n\n    for (const name in config.node) {\n        if (hasOwnProperty.call(config.node, name)) {\n            const nodeType = config.node[name];\n\n            if (!nodeType.structure) {\n                throw new Error('Missed `structure` field in `' + name + '` node type definition');\n            }\n\n            types[name] = getWalkersFromStructure(name, nodeType);\n        }\n    }\n\n    return types;\n}\n\nfunction createTypeIterator(config, reverse) {\n    const fields = config.fields.slice();\n    const contextName = config.context;\n    const useContext = typeof contextName === 'string';\n\n    if (reverse) {\n        fields.reverse();\n    }\n\n    return function(node, context, walk, walkReducer) {\n        let prevContextValue;\n\n        if (useContext) {\n            prevContextValue = context[contextName];\n            context[contextName] = node;\n        }\n\n        for (const field of fields) {\n            const ref = node[field.name];\n\n            if (!field.nullable || ref) {\n                if (field.type === 'list') {\n                    const breakWalk = reverse\n                        ? ref.reduceRight(walkReducer, false)\n                        : ref.reduce(walkReducer, false);\n\n                    if (breakWalk) {\n                        return true;\n                    }\n                } else if (walk(ref)) {\n                    return true;\n                }\n            }\n        }\n\n        if (useContext) {\n            context[contextName] = prevContextValue;\n        }\n    };\n}\n\nfunction createFastTraveralMap({\n    StyleSheet,\n    Atrule,\n    Rule,\n    Block,\n    DeclarationList\n}) {\n    return {\n        Atrule: {\n            StyleSheet,\n            Atrule,\n            Rule,\n            Block\n        },\n        Rule: {\n            StyleSheet,\n            Atrule,\n            Rule,\n            Block\n        },\n        Declaration: {\n            StyleSheet,\n            Atrule,\n            Rule,\n            Block,\n            DeclarationList\n        }\n    };\n}\n\nfunction createWalker(config) {\n    const types = getTypesFromConfig(config);\n    const iteratorsNatural = {};\n    const iteratorsReverse = {};\n    const breakWalk = Symbol('break-walk');\n    const skipNode = Symbol('skip-node');\n\n    for (const name in types) {\n        if (hasOwnProperty.call(types, name) && types[name] !== null) {\n            iteratorsNatural[name] = createTypeIterator(types[name], false);\n            iteratorsReverse[name] = createTypeIterator(types[name], true);\n        }\n    }\n\n    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);\n    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);\n\n    const walk = function(root, options) {\n        function walkNode(node, item, list) {\n            const enterRet = enter.call(context, node, item, list);\n\n            if (enterRet === breakWalk) {\n                return true;\n            }\n\n            if (enterRet === skipNode) {\n                return false;\n            }\n\n            if (iterators.hasOwnProperty(node.type)) {\n                if (iterators[node.type](node, context, walkNode, walkReducer)) {\n                    return true;\n                }\n            }\n\n            if (leave.call(context, node, item, list) === breakWalk) {\n                return true;\n            }\n\n            return false;\n        }\n\n        let enter = noop;\n        let leave = noop;\n        let iterators = iteratorsNatural;\n        let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);\n        const context = {\n            break: breakWalk,\n            skip: skipNode,\n\n            root,\n            stylesheet: null,\n            atrule: null,\n            atrulePrelude: null,\n            rule: null,\n            selector: null,\n            block: null,\n            declaration: null,\n            function: null\n        };\n\n        if (typeof options === 'function') {\n            enter = options;\n        } else if (options) {\n            enter = ensureFunction(options.enter);\n            leave = ensureFunction(options.leave);\n\n            if (options.reverse) {\n                iterators = iteratorsReverse;\n            }\n\n            if (options.visit) {\n                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {\n                    iterators = options.reverse\n                        ? fastTraversalIteratorsReverse[options.visit]\n                        : fastTraversalIteratorsNatural[options.visit];\n                } else if (!types.hasOwnProperty(options.visit)) {\n                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).sort().join(', ') + ')');\n                }\n\n                enter = invokeForType(enter, options.visit);\n                leave = invokeForType(leave, options.visit);\n            }\n        }\n\n        if (enter === noop && leave === noop) {\n            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n        }\n\n        walkNode(root);\n    };\n\n    walk.break = breakWalk;\n    walk.skip = skipNode;\n\n    walk.find = function(ast, fn) {\n        let found = null;\n\n        walk(ast, function(node, item, list) {\n            if (fn.call(this, node, item, list)) {\n                found = node;\n                return breakWalk;\n            }\n        });\n\n        return found;\n    };\n\n    walk.findLast = function(ast, fn) {\n        let found = null;\n\n        walk(ast, {\n            reverse: true,\n            enter(node, item, list) {\n                if (fn.call(this, node, item, list)) {\n                    found = node;\n                    return breakWalk;\n                }\n            }\n        });\n\n        return found;\n    };\n\n    walk.findAll = function(ast, fn) {\n        const found = [];\n\n        walk(ast, function(node, item, list) {\n            if (fn.call(this, node, item, list)) {\n                found.push(node);\n            }\n        });\n\n        return found;\n    };\n\n    return walk;\n}\n\nexports.createWalker = createWalker;\n","'use strict';\n\nfunction noop(value) {\n    return value;\n}\n\nfunction generateMultiplier(multiplier) {\n    const { min, max, comma } = multiplier;\n\n    if (min === 0 && max === 0) {\n        return comma ? '#?' : '*';\n    }\n\n    if (min === 0 && max === 1) {\n        return '?';\n    }\n\n    if (min === 1 && max === 0) {\n        return comma ? '#' : '+';\n    }\n\n    if (min === 1 && max === 1) {\n        return '';\n    }\n\n    return (\n        (comma ? '#' : '') +\n        (min === max\n            ? '{' + min + '}'\n            : '{' + min + ',' + (max !== 0 ? max : '') + '}'\n        )\n    );\n}\n\nfunction generateTypeOpts(node) {\n    switch (node.type) {\n        case 'Range':\n            return (\n                ' [' +\n                (node.min === null ? '-∞' : node.min) +\n                ',' +\n                (node.max === null ? '∞' : node.max) +\n                ']'\n            );\n\n        default:\n            throw new Error('Unknown node type `' + node.type + '`');\n    }\n}\n\nfunction generateSequence(node, decorate, forceBraces, compact) {\n    const combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';\n    const result = node.terms\n        .map(term => internalGenerate(term, decorate, forceBraces, compact))\n        .join(combinator);\n\n    if (node.explicit || forceBraces) {\n        return (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');\n    }\n\n    return result;\n}\n\nfunction internalGenerate(node, decorate, forceBraces, compact) {\n    let result;\n\n    switch (node.type) {\n        case 'Group':\n            result =\n                generateSequence(node, decorate, forceBraces, compact) +\n                (node.disallowEmpty ? '!' : '');\n            break;\n\n        case 'Multiplier':\n            // return since node is a composition\n            return (\n                internalGenerate(node.term, decorate, forceBraces, compact) +\n                decorate(generateMultiplier(node), node)\n            );\n\n        case 'Type':\n            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';\n            break;\n\n        case 'Property':\n            result = '<\\'' + node.name + '\\'>';\n            break;\n\n        case 'Keyword':\n            result = node.name;\n            break;\n\n        case 'AtKeyword':\n            result = '@' + node.name;\n            break;\n\n        case 'Function':\n            result = node.name + '(';\n            break;\n\n        case 'String':\n        case 'Token':\n            result = node.value;\n            break;\n\n        case 'Comma':\n            result = ',';\n            break;\n\n        default:\n            throw new Error('Unknown node type `' + node.type + '`');\n    }\n\n    return decorate(result, node);\n}\n\nfunction generate(node, options) {\n    let decorate = noop;\n    let forceBraces = false;\n    let compact = false;\n\n    if (typeof options === 'function') {\n        decorate = options;\n    } else if (options) {\n        forceBraces = Boolean(options.forceBraces);\n        compact = Boolean(options.compact);\n        if (typeof options.decorate === 'function') {\n            decorate = options.decorate;\n        }\n    }\n\n    return internalGenerate(node, decorate, forceBraces, compact);\n}\n\nexports.generate = generate;\n","'use strict';\n\nconst createCustomError = require('../utils/create-custom-error.cjs');\nconst generate = require('../definition-syntax/generate.cjs');\n\nconst defaultLoc = { offset: 0, line: 1, column: 1 };\n\nfunction locateMismatch(matchResult, node) {\n    const tokens = matchResult.tokens;\n    const longestMatch = matchResult.longestMatch;\n    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;\n    const badNode = mismatchNode !== node ? mismatchNode : null;\n    let mismatchOffset = 0;\n    let mismatchLength = 0;\n    let entries = 0;\n    let css = '';\n    let start;\n    let end;\n\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i].value;\n\n        if (i === longestMatch) {\n            mismatchLength = token.length;\n            mismatchOffset = css.length;\n        }\n\n        if (badNode !== null && tokens[i].node === badNode) {\n            if (i <= longestMatch) {\n                entries++;\n            } else {\n                entries = 0;\n            }\n        }\n\n        css += token;\n    }\n\n    if (longestMatch === tokens.length || entries > 1) { // last\n        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);\n        end = buildLoc(start);\n    } else {\n        start = fromLoc(badNode, 'start') ||\n            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));\n        end = fromLoc(badNode, 'end') ||\n            buildLoc(start, css.substr(mismatchOffset, mismatchLength));\n    }\n\n    return {\n        css,\n        mismatchOffset,\n        mismatchLength,\n        start,\n        end\n    };\n}\n\nfunction fromLoc(node, point) {\n    const value = node && node.loc && node.loc[point];\n\n    if (value) {\n        return 'line' in value ? buildLoc(value) : value;\n    }\n\n    return null;\n}\n\nfunction buildLoc({ offset, line, column }, extra) {\n    const loc = {\n        offset,\n        line,\n        column\n    };\n\n    if (extra) {\n        const lines = extra.split(/\\n|\\r\\n?|\\f/);\n\n        loc.offset += extra.length;\n        loc.line += lines.length - 1;\n        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;\n    }\n\n    return loc;\n}\n\nconst SyntaxReferenceError = function(type, referenceName) {\n    const error = createCustomError.createCustomError(\n        'SyntaxReferenceError',\n        type + (referenceName ? ' `' + referenceName + '`' : '')\n    );\n\n    error.reference = referenceName;\n\n    return error;\n};\n\nconst SyntaxMatchError = function(message, syntax, node, matchResult) {\n    const error = createCustomError.createCustomError('SyntaxMatchError', message);\n    const {\n        css,\n        mismatchOffset,\n        mismatchLength,\n        start,\n        end\n    } = locateMismatch(matchResult, node);\n\n    error.rawMessage = message;\n    error.syntax = syntax ? generate.generate(syntax) : '<generic>';\n    error.css = css;\n    error.mismatchOffset = mismatchOffset;\n    error.mismatchLength = mismatchLength;\n    error.message = message + '\\n' +\n        '  syntax: ' + error.syntax + '\\n' +\n        '   value: ' + (css || '<empty string>') + '\\n' +\n        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n\n    Object.assign(error, start);\n    error.loc = {\n        source: (node && node.loc && node.loc.source) || '<unknown>',\n        start,\n        end\n    };\n\n    return error;\n};\n\nexports.SyntaxMatchError = SyntaxMatchError;\nexports.SyntaxReferenceError = SyntaxReferenceError;\n","'use strict';\n\nconst keywords = new Map();\nconst properties = new Map();\nconst HYPHENMINUS = 45; // '-'.charCodeAt()\n\nconst keyword = getKeywordDescriptor;\nconst property = getPropertyDescriptor;\nconst vendorPrefix = getVendorPrefix;\nfunction isCustomProperty(str, offset) {\n    offset = offset || 0;\n\n    return str.length - offset >= 2 &&\n           str.charCodeAt(offset) === HYPHENMINUS &&\n           str.charCodeAt(offset + 1) === HYPHENMINUS;\n}\n\nfunction getVendorPrefix(str, offset) {\n    offset = offset || 0;\n\n    // verdor prefix should be at least 3 chars length\n    if (str.length - offset >= 3) {\n        // vendor prefix starts with hyper minus following non-hyper minus\n        if (str.charCodeAt(offset) === HYPHENMINUS &&\n            str.charCodeAt(offset + 1) !== HYPHENMINUS) {\n            // vendor prefix should contain a hyper minus at the ending\n            const secondDashIndex = str.indexOf('-', offset + 2);\n\n            if (secondDashIndex !== -1) {\n                return str.substring(offset, secondDashIndex + 1);\n            }\n        }\n    }\n\n    return '';\n}\n\nfunction getKeywordDescriptor(keyword) {\n    if (keywords.has(keyword)) {\n        return keywords.get(keyword);\n    }\n\n    const name = keyword.toLowerCase();\n    let descriptor = keywords.get(name);\n\n    if (descriptor === undefined) {\n        const custom = isCustomProperty(name, 0);\n        const vendor = !custom ? getVendorPrefix(name, 0) : '';\n        descriptor = Object.freeze({\n            basename: name.substr(vendor.length),\n            name,\n            prefix: vendor,\n            vendor,\n            custom\n        });\n    }\n\n    keywords.set(keyword, descriptor);\n\n    return descriptor;\n}\n\nfunction getPropertyDescriptor(property) {\n    if (properties.has(property)) {\n        return properties.get(property);\n    }\n\n    let name = property;\n    let hack = property[0];\n\n    if (hack === '/') {\n        hack = property[1] === '/' ? '//' : '/';\n    } else if (hack !== '_' &&\n               hack !== '*' &&\n               hack !== '$' &&\n               hack !== '#' &&\n               hack !== '+' &&\n               hack !== '&') {\n        hack = '';\n    }\n\n    const custom = isCustomProperty(name, hack.length);\n\n    // re-use result when possible (the same as for lower case)\n    if (!custom) {\n        name = name.toLowerCase();\n        if (properties.has(name)) {\n            const descriptor = properties.get(name);\n            properties.set(property, descriptor);\n            return descriptor;\n        }\n    }\n\n    const vendor = !custom ? getVendorPrefix(name, hack.length) : '';\n    const prefix = name.substr(0, hack.length + vendor.length);\n    const descriptor = Object.freeze({\n        basename: name.substr(prefix.length),\n        name: name.substr(hack.length),\n        hack,\n        vendor,\n        prefix,\n        custom\n    });\n\n    properties.set(property, descriptor);\n\n    return descriptor;\n}\n\nexports.isCustomProperty = isCustomProperty;\nexports.keyword = keyword;\nexports.property = property;\nexports.vendorPrefix = vendorPrefix;\n","'use strict';\n\n// https://drafts.csswg.org/css-cascade-5/\nconst cssWideKeywords = [\n    'initial',\n    'inherit',\n    'unset',\n    'revert',\n    'revert-layer'\n];\n\nexports.cssWideKeywords = cssWideKeywords;\n","'use strict';\n\nconst charCodeDefinitions = require('../tokenizer/char-code-definitions.cjs');\nconst types = require('../tokenizer/types.cjs');\nconst utils = require('../tokenizer/utils.cjs');\n\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)\nconst DISALLOW_SIGN = true;\nconst ALLOW_SIGN = false;\n\nfunction isDelim(token, code) {\n    return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;\n}\n\nfunction skipSC(token, offset, getNextToken) {\n    while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment)) {\n        token = getNextToken(++offset);\n    }\n\n    return offset;\n}\n\nfunction checkInteger(token, valueOffset, disallowSign, offset) {\n    if (!token) {\n        return 0;\n    }\n\n    const code = token.value.charCodeAt(valueOffset);\n\n    if (code === PLUSSIGN || code === HYPHENMINUS) {\n        if (disallowSign) {\n            // Number sign is not allowed\n            return 0;\n        }\n        valueOffset++;\n    }\n\n    for (; valueOffset < token.value.length; valueOffset++) {\n        if (!charCodeDefinitions.isDigit(token.value.charCodeAt(valueOffset))) {\n            // Integer is expected\n            return 0;\n        }\n    }\n\n    return offset + 1;\n}\n\n// ... <signed-integer>\n// ... ['+' | '-'] <signless-integer>\nfunction consumeB(token, offset_, getNextToken) {\n    let sign = false;\n    let offset = skipSC(token, offset_, getNextToken);\n\n    token = getNextToken(offset);\n\n    if (token === null) {\n        return offset_;\n    }\n\n    if (token.type !== types.Number) {\n        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {\n            sign = true;\n            offset = skipSC(getNextToken(++offset), offset, getNextToken);\n            token = getNextToken(offset);\n\n            if (token === null || token.type !== types.Number) {\n                return 0;\n            }\n        } else {\n            return offset_;\n        }\n    }\n\n    if (!sign) {\n        const code = token.value.charCodeAt(0);\n        if (code !== PLUSSIGN && code !== HYPHENMINUS) {\n            // Number sign is expected\n            return 0;\n        }\n    }\n\n    return checkInteger(token, sign ? 0 : 1, sign, offset);\n}\n\n// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\nfunction anPlusB(token, getNextToken) {\n    /* eslint-disable brace-style*/\n    let offset = 0;\n\n    if (!token) {\n        return 0;\n    }\n\n    // <integer>\n    if (token.type === types.Number) {\n        return checkInteger(token, 0, ALLOW_SIGN, offset); // b\n    }\n\n    // -n\n    // -n <signed-integer>\n    // -n ['+' | '-'] <signless-integer>\n    // -n- <signless-integer>\n    // <dashndashdigit-ident>\n    else if (token.type === types.Ident && token.value.charCodeAt(0) === HYPHENMINUS) {\n        // expect 1st char is N\n        if (!utils.cmpChar(token.value, 1, N)) {\n            return 0;\n        }\n\n        switch (token.value.length) {\n            // -n\n            // -n <signed-integer>\n            // -n ['+' | '-'] <signless-integer>\n            case 2:\n                return consumeB(getNextToken(++offset), offset, getNextToken);\n\n            // -n- <signless-integer>\n            case 3:\n                if (token.value.charCodeAt(2) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                token = getNextToken(offset);\n\n                return checkInteger(token, 0, DISALLOW_SIGN, offset);\n\n            // <dashndashdigit-ident>\n            default:\n                if (token.value.charCodeAt(2) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                return checkInteger(token, 3, DISALLOW_SIGN, offset);\n        }\n    }\n\n    // '+'? n\n    // '+'? n <signed-integer>\n    // '+'? n ['+' | '-'] <signless-integer>\n    // '+'? n- <signless-integer>\n    // '+'? <ndashdigit-ident>\n    else if (token.type === types.Ident || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === types.Ident)) {\n        // just ignore a plus\n        if (token.type !== types.Ident) {\n            token = getNextToken(++offset);\n        }\n\n        if (token === null || !utils.cmpChar(token.value, 0, N)) {\n            return 0;\n        }\n\n        switch (token.value.length) {\n            // '+'? n\n            // '+'? n <signed-integer>\n            // '+'? n ['+' | '-'] <signless-integer>\n            case 1:\n                return consumeB(getNextToken(++offset), offset, getNextToken);\n\n            // '+'? n- <signless-integer>\n            case 2:\n                if (token.value.charCodeAt(1) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                token = getNextToken(offset);\n\n                return checkInteger(token, 0, DISALLOW_SIGN, offset);\n\n            // '+'? <ndashdigit-ident>\n            default:\n                if (token.value.charCodeAt(1) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                return checkInteger(token, 2, DISALLOW_SIGN, offset);\n        }\n    }\n\n    // <ndashdigit-dimension>\n    // <ndash-dimension> <signless-integer>\n    // <n-dimension>\n    // <n-dimension> <signed-integer>\n    // <n-dimension> ['+' | '-'] <signless-integer>\n    else if (token.type === types.Dimension) {\n        let code = token.value.charCodeAt(0);\n        let sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;\n        let i = sign;\n\n        for (; i < token.value.length; i++) {\n            if (!charCodeDefinitions.isDigit(token.value.charCodeAt(i))) {\n                break;\n            }\n        }\n\n        if (i === sign) {\n            // Integer is expected\n            return 0;\n        }\n\n        if (!utils.cmpChar(token.value, i, N)) {\n            return 0;\n        }\n\n        // <n-dimension>\n        // <n-dimension> <signed-integer>\n        // <n-dimension> ['+' | '-'] <signless-integer>\n        if (i + 1 === token.value.length) {\n            return consumeB(getNextToken(++offset), offset, getNextToken);\n        } else {\n            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {\n                return 0;\n            }\n\n            // <ndash-dimension> <signless-integer>\n            if (i + 2 === token.value.length) {\n                offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                token = getNextToken(offset);\n\n                return checkInteger(token, 0, DISALLOW_SIGN, offset);\n            }\n            // <ndashdigit-dimension>\n            else {\n                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);\n            }\n        }\n    }\n\n    return 0;\n}\n\nmodule.exports = anPlusB;\n","'use strict';\n\nconst charCodeDefinitions = require('../tokenizer/char-code-definitions.cjs');\nconst types = require('../tokenizer/types.cjs');\nconst utils = require('../tokenizer/utils.cjs');\n\nconst PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)\nconst QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\nconst U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)\n\nfunction isDelim(token, code) {\n    return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;\n}\n\nfunction startsWith(token, code) {\n    return token.value.charCodeAt(0) === code;\n}\n\nfunction hexSequence(token, offset, allowDash) {\n    let hexlen = 0;\n\n    for (let pos = offset; pos < token.value.length; pos++) {\n        const code = token.value.charCodeAt(pos);\n\n        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {\n            hexSequence(token, offset + hexlen + 1, false);\n            return 6; // dissallow following question marks\n        }\n\n        if (!charCodeDefinitions.isHexDigit(code)) {\n            return 0; // not a hex digit\n        }\n\n        if (++hexlen > 6) {\n            return 0; // too many hex digits\n        }    }\n\n    return hexlen;\n}\n\nfunction withQuestionMarkSequence(consumed, length, getNextToken) {\n    if (!consumed) {\n        return 0; // nothing consumed\n    }\n\n    while (isDelim(getNextToken(length), QUESTIONMARK)) {\n        if (++consumed > 6) {\n            return 0; // too many question marks\n        }\n\n        length++;\n    }\n\n    return length;\n}\n\n// https://drafts.csswg.org/css-syntax/#urange\n// Informally, the <urange> production has three forms:\n// U+0001\n//      Defines a range consisting of a single code point, in this case the code point \"1\".\n// U+0001-00ff\n//      Defines a range of codepoints between the first and the second value, in this case\n//      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n// U+00??\n//      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n//      in this case defining the same as the value U+0000-00ff.\n// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n//\n// <urange> =\n//   u '+' <ident-token> '?'* |\n//   u <dimension-token> '?'* |\n//   u <number-token> '?'* |\n//   u <number-token> <dimension-token> |\n//   u <number-token> <number-token> |\n//   u '+' '?'+\nfunction urange(token, getNextToken) {\n    let length = 0;\n\n    // should start with `u` or `U`\n    if (token === null || token.type !== types.Ident || !utils.cmpChar(token.value, 0, U)) {\n        return 0;\n    }\n\n    token = getNextToken(++length);\n    if (token === null) {\n        return 0;\n    }\n\n    // u '+' <ident-token> '?'*\n    // u '+' '?'+\n    if (isDelim(token, PLUSSIGN)) {\n        token = getNextToken(++length);\n        if (token === null) {\n            return 0;\n        }\n\n        if (token.type === types.Ident) {\n            // u '+' <ident-token> '?'*\n            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);\n        }\n\n        if (isDelim(token, QUESTIONMARK)) {\n            // u '+' '?'+\n            return withQuestionMarkSequence(1, ++length, getNextToken);\n        }\n\n        // Hex digit or question mark is expected\n        return 0;\n    }\n\n    // u <number-token> '?'*\n    // u <number-token> <dimension-token>\n    // u <number-token> <number-token>\n    if (token.type === types.Number) {\n        const consumedHexLength = hexSequence(token, 1, true);\n        if (consumedHexLength === 0) {\n            return 0;\n        }\n\n        token = getNextToken(++length);\n        if (token === null) {\n            // u <number-token> <eof>\n            return length;\n        }\n\n        if (token.type === types.Dimension || token.type === types.Number) {\n            // u <number-token> <dimension-token>\n            // u <number-token> <number-token>\n            if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {\n                return 0;\n            }\n\n            return length + 1;\n        }\n\n        // u <number-token> '?'*\n        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);\n    }\n\n    // u <dimension-token> '?'*\n    if (token.type === types.Dimension) {\n        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);\n    }\n\n    return 0;\n}\n\nmodule.exports = urange;\n","'use strict';\n\nconst genericConst = require('./generic-const.cjs');\nconst genericAnPlusB = require('./generic-an-plus-b.cjs');\nconst genericUrange = require('./generic-urange.cjs');\nconst types = require('../tokenizer/types.cjs');\nconst charCodeDefinitions = require('../tokenizer/char-code-definitions.cjs');\nconst utils = require('../tokenizer/utils.cjs');\n\nconst calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];\nconst balancePair = new Map([\n    [types.Function, types.RightParenthesis],\n    [types.LeftParenthesis, types.RightParenthesis],\n    [types.LeftSquareBracket, types.RightSquareBracket],\n    [types.LeftCurlyBracket, types.RightCurlyBracket]\n]);\n\n// safe char code getter\nfunction charCodeAt(str, index) {\n    return index < str.length ? str.charCodeAt(index) : 0;\n}\n\nfunction eqStr(actual, expected) {\n    return utils.cmpStr(actual, 0, actual.length, expected);\n}\n\nfunction eqStrAny(actual, expected) {\n    for (let i = 0; i < expected.length; i++) {\n        if (eqStr(actual, expected[i])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// IE postfix hack, i.e. 123\\0 or 123px\\9\nfunction isPostfixIeHack(str, offset) {\n    if (offset !== str.length - 2) {\n        return false;\n    }\n\n    return (\n        charCodeAt(str, offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\\)\n        charCodeDefinitions.isDigit(charCodeAt(str, offset + 1))\n    );\n}\n\nfunction outOfRange(opts, value, numEnd) {\n    if (opts && opts.type === 'Range') {\n        const num = Number(\n            numEnd !== undefined && numEnd !== value.length\n                ? value.substr(0, numEnd)\n                : value\n        );\n\n        if (isNaN(num)) {\n            return true;\n        }\n\n        // FIXME: when opts.min is a string it's a dimension, skip a range validation\n        // for now since it requires a type covertation which is not implmented yet\n        if (opts.min !== null && num < opts.min && typeof opts.min !== 'string') {\n            return true;\n        }\n\n        // FIXME: when opts.max is a string it's a dimension, skip a range validation\n        // for now since it requires a type covertation which is not implmented yet\n        if (opts.max !== null && num > opts.max && typeof opts.max !== 'string') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction consumeFunction(token, getNextToken) {\n    let balanceCloseType = 0;\n    let balanceStash = [];\n    let length = 0;\n\n    // balanced token consuming\n    scan:\n    do {\n        switch (token.type) {\n            case types.RightCurlyBracket:\n            case types.RightParenthesis:\n            case types.RightSquareBracket:\n                if (token.type !== balanceCloseType) {\n                    break scan;\n                }\n\n                balanceCloseType = balanceStash.pop();\n\n                if (balanceStash.length === 0) {\n                    length++;\n                    break scan;\n                }\n\n                break;\n\n            case types.Function:\n            case types.LeftParenthesis:\n            case types.LeftSquareBracket:\n            case types.LeftCurlyBracket:\n                balanceStash.push(balanceCloseType);\n                balanceCloseType = balancePair.get(token.type);\n                break;\n        }\n\n        length++;\n    } while (token = getNextToken(length));\n\n    return length;\n}\n\n// TODO: implement\n// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed\n// https://drafts.csswg.org/css-values/#calc-notation\nfunction calc(next) {\n    return function(token, getNextToken, opts) {\n        if (token === null) {\n            return 0;\n        }\n\n        if (token.type === types.Function && eqStrAny(token.value, calcFunctionNames)) {\n            return consumeFunction(token, getNextToken);\n        }\n\n        return next(token, getNextToken, opts);\n    };\n}\n\nfunction tokenType(expectedTokenType) {\n    return function(token) {\n        if (token === null || token.type !== expectedTokenType) {\n            return 0;\n        }\n\n        return 1;\n    };\n}\n\n// =========================\n// Complex types\n//\n\n// https://drafts.csswg.org/css-values-4/#custom-idents\n// 4.2. Author-defined Identifiers: the <custom-ident> type\n// Some properties accept arbitrary author-defined identifiers as a component value.\n// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier\n// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.\n//\n// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident\nfunction customIdent(token) {\n    if (token === null || token.type !== types.Ident) {\n        return 0;\n    }\n\n    const name = token.value.toLowerCase();\n\n    // The CSS-wide keywords are not valid <custom-ident>s\n    if (eqStrAny(name, genericConst.cssWideKeywords)) {\n        return 0;\n    }\n\n    // The default keyword is reserved and is also not a valid <custom-ident>\n    if (eqStr(name, 'default')) {\n        return 0;\n    }\n\n    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)\n    // Specifications using <custom-ident> must specify clearly what other keywords\n    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords\n    // in that property’s value definition are excluded. Excluded keywords are excluded\n    // in all ASCII case permutations.\n\n    return 1;\n}\n\n// https://drafts.csswg.org/css-variables/#typedef-custom-property-name\n// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.\n// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier\n// that starts with two dashes, except -- itself, which is reserved for future use by CSS.\n// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.\nfunction customPropertyName(token) {\n    // ... defined as any valid identifier\n    if (token === null || token.type !== types.Ident) {\n        return 0;\n    }\n\n    // ... that starts with two dashes (U+002D HYPHEN-MINUS)\n    if (charCodeAt(token.value, 0) !== 0x002D || charCodeAt(token.value, 1) !== 0x002D) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// https://drafts.csswg.org/css-color-4/#hex-notation\n// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.\n// In other words, a hex color is written as a hash character, \"#\", followed by some number of digits 0-9 or\n// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).\nfunction hexColor(token) {\n    if (token === null || token.type !== types.Hash) {\n        return 0;\n    }\n\n    const length = token.value.length;\n\n    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)\n    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {\n        return 0;\n    }\n\n    for (let i = 1; i < length; i++) {\n        if (!charCodeDefinitions.isHexDigit(charCodeAt(token.value, i))) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\nfunction idSelector(token) {\n    if (token === null || token.type !== types.Hash) {\n        return 0;\n    }\n\n    if (!charCodeDefinitions.isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// https://drafts.csswg.org/css-syntax/#any-value\n// It represents the entirety of what a valid declaration can have as its value.\nfunction declarationValue(token, getNextToken) {\n    if (!token) {\n        return 0;\n    }\n\n    let balanceCloseType = 0;\n    let balanceStash = [];\n    let length = 0;\n\n    // The <declaration-value> production matches any sequence of one or more tokens,\n    // so long as the sequence does not contain ...\n    scan:\n    do {\n        switch (token.type) {\n            // ... <bad-string-token>, <bad-url-token>,\n            case types.BadString:\n            case types.BadUrl:\n                break scan;\n\n            // ... unmatched <)-token>, <]-token>, or <}-token>,\n            case types.RightCurlyBracket:\n            case types.RightParenthesis:\n            case types.RightSquareBracket:\n                if (token.type !== balanceCloseType) {\n                    break scan;\n                }\n\n                balanceCloseType = balanceStash.pop();\n                break;\n\n            // ... or top-level <semicolon-token> tokens\n            case types.Semicolon:\n                if (balanceCloseType === 0) {\n                    break scan;\n                }\n\n                break;\n\n            // ... or <delim-token> tokens with a value of \"!\"\n            case types.Delim:\n                if (balanceCloseType === 0 && token.value === '!') {\n                    break scan;\n                }\n\n                break;\n\n            case types.Function:\n            case types.LeftParenthesis:\n            case types.LeftSquareBracket:\n            case types.LeftCurlyBracket:\n                balanceStash.push(balanceCloseType);\n                balanceCloseType = balancePair.get(token.type);\n                break;\n        }\n\n        length++;\n    } while (token = getNextToken(length));\n\n    return length;\n}\n\n// https://drafts.csswg.org/css-syntax/#any-value\n// The <any-value> production is identical to <declaration-value>, but also\n// allows top-level <semicolon-token> tokens and <delim-token> tokens\n// with a value of \"!\". It represents the entirety of what valid CSS can be in any context.\nfunction anyValue(token, getNextToken) {\n    if (!token) {\n        return 0;\n    }\n\n    let balanceCloseType = 0;\n    let balanceStash = [];\n    let length = 0;\n\n    // The <any-value> production matches any sequence of one or more tokens,\n    // so long as the sequence ...\n    scan:\n    do {\n        switch (token.type) {\n            // ... does not contain <bad-string-token>, <bad-url-token>,\n            case types.BadString:\n            case types.BadUrl:\n                break scan;\n\n            // ... unmatched <)-token>, <]-token>, or <}-token>,\n            case types.RightCurlyBracket:\n            case types.RightParenthesis:\n            case types.RightSquareBracket:\n                if (token.type !== balanceCloseType) {\n                    break scan;\n                }\n\n                balanceCloseType = balanceStash.pop();\n                break;\n\n            case types.Function:\n            case types.LeftParenthesis:\n            case types.LeftSquareBracket:\n            case types.LeftCurlyBracket:\n                balanceStash.push(balanceCloseType);\n                balanceCloseType = balancePair.get(token.type);\n                break;\n        }\n\n        length++;\n    } while (token = getNextToken(length));\n\n    return length;\n}\n\n// =========================\n// Dimensions\n//\n\nfunction dimension(type) {\n    if (type) {\n        type = new Set(type);\n    }\n\n    return function(token, getNextToken, opts) {\n        if (token === null || token.type !== types.Dimension) {\n            return 0;\n        }\n\n        const numberEnd = utils.consumeNumber(token.value, 0);\n\n        // check unit\n        if (type !== null) {\n            // check for IE postfix hack, i.e. 123px\\0 or 123px\\9\n            const reverseSolidusOffset = token.value.indexOf('\\\\', numberEnd);\n            const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)\n                ? token.value.substr(numberEnd)\n                : token.value.substring(numberEnd, reverseSolidusOffset);\n\n            if (type.has(unit.toLowerCase()) === false) {\n                return 0;\n            }\n        }\n\n        // check range if specified\n        if (outOfRange(opts, token.value, numberEnd)) {\n            return 0;\n        }\n\n        return 1;\n    };\n}\n\n// =========================\n// Percentage\n//\n\n// §5.5. Percentages: the <percentage> type\n// https://drafts.csswg.org/css-values-4/#percentages\nfunction percentage(token, getNextToken, opts) {\n    // ... corresponds to the <percentage-token> production\n    if (token === null || token.type !== types.Percentage) {\n        return 0;\n    }\n\n    // check range if specified\n    if (outOfRange(opts, token.value, token.value.length - 1)) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// =========================\n// Numeric\n//\n\n// https://drafts.csswg.org/css-values-4/#numbers\n// The value <zero> represents a literal number with the value 0. Expressions that merely\n// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;\n// only literal <number-token>s do.\nfunction zero(next) {\n    if (typeof next !== 'function') {\n        next = function() {\n            return 0;\n        };\n    }\n\n    return function(token, getNextToken, opts) {\n        if (token !== null && token.type === types.Number) {\n            if (Number(token.value) === 0) {\n                return 1;\n            }\n        }\n\n        return next(token, getNextToken, opts);\n    };\n}\n\n// § 5.3. Real Numbers: the <number> type\n// https://drafts.csswg.org/css-values-4/#numbers\n// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.\n// ... It corresponds to the <number-token> production\nfunction number(token, getNextToken, opts) {\n    if (token === null) {\n        return 0;\n    }\n\n    const numberEnd = utils.consumeNumber(token.value, 0);\n    const isNumber = numberEnd === token.value.length;\n    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {\n        return 0;\n    }\n\n    // check range if specified\n    if (outOfRange(opts, token.value, numberEnd)) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// §5.2. Integers: the <integer> type\n// https://drafts.csswg.org/css-values-4/#integers\nfunction integer(token, getNextToken, opts) {\n    // ... corresponds to a subset of the <number-token> production\n    if (token === null || token.type !== types.Number) {\n        return 0;\n    }\n\n    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.\n    let i = charCodeAt(token.value, 0) === 0x002B ||       // U+002B PLUS SIGN (+)\n            charCodeAt(token.value, 0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)\n\n    // When written literally, an integer is one or more decimal digits 0 through 9 ...\n    for (; i < token.value.length; i++) {\n        if (!charCodeDefinitions.isDigit(charCodeAt(token.value, i))) {\n            return 0;\n        }\n    }\n\n    // check range if specified\n    if (outOfRange(opts, token.value, i)) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// token types\nconst tokenTypes = {\n    'ident-token': tokenType(types.Ident),\n    'function-token': tokenType(types.Function),\n    'at-keyword-token': tokenType(types.AtKeyword),\n    'hash-token': tokenType(types.Hash),\n    'string-token': tokenType(types.String),\n    'bad-string-token': tokenType(types.BadString),\n    'url-token': tokenType(types.Url),\n    'bad-url-token': tokenType(types.BadUrl),\n    'delim-token': tokenType(types.Delim),\n    'number-token': tokenType(types.Number),\n    'percentage-token': tokenType(types.Percentage),\n    'dimension-token': tokenType(types.Dimension),\n    'whitespace-token': tokenType(types.WhiteSpace),\n    'CDO-token': tokenType(types.CDO),\n    'CDC-token': tokenType(types.CDC),\n    'colon-token': tokenType(types.Colon),\n    'semicolon-token': tokenType(types.Semicolon),\n    'comma-token': tokenType(types.Comma),\n    '[-token': tokenType(types.LeftSquareBracket),\n    ']-token': tokenType(types.RightSquareBracket),\n    '(-token': tokenType(types.LeftParenthesis),\n    ')-token': tokenType(types.RightParenthesis),\n    '{-token': tokenType(types.LeftCurlyBracket),\n    '}-token': tokenType(types.RightCurlyBracket)\n};\n\n// token production types\nconst productionTypes = {\n    // token type aliases\n    'string': tokenType(types.String),\n    'ident': tokenType(types.Ident),\n\n    // percentage\n    'percentage': calc(percentage),\n\n    // numeric\n    'zero': zero(),\n    'number': calc(number),\n    'integer': calc(integer),\n\n    // complex types\n    'custom-ident': customIdent,\n    'custom-property-name': customPropertyName,\n    'hex-color': hexColor,\n    'id-selector': idSelector, // element( <id-selector> )\n    'an-plus-b': genericAnPlusB,\n    'urange': genericUrange,\n    'declaration-value': declarationValue,\n    'any-value': anyValue\n};\n\n// dimensions types depend on units set\nfunction createDemensionTypes(units) {\n    const {\n        angle,\n        decibel,\n        frequency,\n        flex,\n        length,\n        resolution,\n        semitones,\n        time\n    } = units || {};\n\n    return {\n        'dimension': calc(dimension(null)),\n        'angle': calc(dimension(angle)),\n        'decibel': calc(dimension(decibel)),\n        'frequency': calc(dimension(frequency)),\n        'flex': calc(dimension(flex)),\n        'length': calc(zero(dimension(length))),\n        'resolution': calc(dimension(resolution)),\n        'semitones': calc(dimension(semitones)),\n        'time': calc(dimension(time))\n    };\n}\n\nfunction createGenericTypes(units) {\n    return {\n        ...tokenTypes,\n        ...productionTypes,\n        ...createDemensionTypes(units)\n    };\n}\n\nexports.createDemensionTypes = createDemensionTypes;\nexports.createGenericTypes = createGenericTypes;\nexports.productionTypes = productionTypes;\nexports.tokenTypes = tokenTypes;\n","'use strict';\n\nconst length = [\n    // absolute length units https://www.w3.org/TR/css-values-3/#lengths\n    'cm', 'mm', 'q', 'in', 'pt', 'pc', 'px',\n    // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths\n    'em', 'rem',\n    'ex', 'rex',\n    'cap', 'rcap',\n    'ch', 'rch',\n    'ic', 'ric',\n    'lh', 'rlh',\n    // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths\n    'vw', 'svw', 'lvw', 'dvw',\n    'vh', 'svh', 'lvh', 'dvh',\n    'vi', 'svi', 'lvi', 'dvi',\n    'vb', 'svb', 'lvb', 'dvb',\n    'vmin', 'svmin', 'lvmin', 'dvmin',\n    'vmax', 'svmax', 'lvmax', 'dvmax',\n    // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths\n    'cqw', 'cqh', 'cqi', 'cqb', 'cqmin', 'cqmax'\n];\nconst angle = ['deg', 'grad', 'rad', 'turn'];    // https://www.w3.org/TR/css-values-3/#angles\nconst time = ['s', 'ms'];                        // https://www.w3.org/TR/css-values-3/#time\nconst frequency = ['hz', 'khz'];                 // https://www.w3.org/TR/css-values-3/#frequency\nconst resolution = ['dpi', 'dpcm', 'dppx', 'x']; // https://www.w3.org/TR/css-values-3/#resolution\nconst flex = ['fr'];                             // https://drafts.csswg.org/css-grid/#fr-unit\nconst decibel = ['db'];                          // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume\nconst semitones = ['st'];                        // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch\n\nexports.angle = angle;\nexports.decibel = decibel;\nexports.flex = flex;\nexports.frequency = frequency;\nexports.length = length;\nexports.resolution = resolution;\nexports.semitones = semitones;\nexports.time = time;\n","'use strict';\n\nconst index = require('../tokenizer/index.cjs');\n\nconst astToTokens = {\n    decorator(handlers) {\n        const tokens = [];\n        let curNode = null;\n\n        return {\n            ...handlers,\n            node(node) {\n                const tmp = curNode;\n                curNode = node;\n                handlers.node.call(this, node);\n                curNode = tmp;\n            },\n            emit(value, type, auto) {\n                tokens.push({\n                    type,\n                    value,\n                    node: auto ? null : curNode\n                });\n            },\n            result() {\n                return tokens;\n            }\n        };\n    }\n};\n\nfunction stringToTokens(str) {\n    const tokens = [];\n\n    index.tokenize(str, (type, start, end) =>\n        tokens.push({\n            type,\n            value: str.slice(start, end),\n            node: null\n        })\n    );\n\n    return tokens;\n}\n\nfunction prepareTokens(value, syntax) {\n    if (typeof value === 'string') {\n        return stringToTokens(value);\n    }\n\n    return syntax.generate(value, astToTokens);\n}\n\nmodule.exports = prepareTokens;\n","'use strict';\n\nconst createCustomError = require('../utils/create-custom-error.cjs');\n\nfunction SyntaxError(message, input, offset) {\n    return Object.assign(createCustomError.createCustomError('SyntaxError', message), {\n        input,\n        offset,\n        rawMessage: message,\n        message: message + '\\n' +\n            '  ' + input + '\\n' +\n            '--' + new Array((offset || input.length) + 1).join('-') + '^'\n    });\n}\n\nexports.SyntaxError = SyntaxError;\n","'use strict';\n\nconst SyntaxError = require('./SyntaxError.cjs');\n\nconst TAB = 9;\nconst N = 10;\nconst F = 12;\nconst R = 13;\nconst SPACE = 32;\n\nclass Tokenizer {\n    constructor(str) {\n        this.str = str;\n        this.pos = 0;\n    }\n    charCodeAt(pos) {\n        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;\n    }\n    charCode() {\n        return this.charCodeAt(this.pos);\n    }\n    nextCharCode() {\n        return this.charCodeAt(this.pos + 1);\n    }\n    nextNonWsCode(pos) {\n        return this.charCodeAt(this.findWsEnd(pos));\n    }\n    findWsEnd(pos) {\n        for (; pos < this.str.length; pos++) {\n            const code = this.str.charCodeAt(pos);\n            if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {\n                break;\n            }\n        }\n\n        return pos;\n    }\n    substringToPos(end) {\n        return this.str.substring(this.pos, this.pos = end);\n    }\n    eat(code) {\n        if (this.charCode() !== code) {\n            this.error('Expect `' + String.fromCharCode(code) + '`');\n        }\n\n        this.pos++;\n    }\n    peek() {\n        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';\n    }\n    error(message) {\n        throw new SyntaxError.SyntaxError(message, this.str, this.pos);\n    }\n}\n\nexports.Tokenizer = Tokenizer;\n","'use strict';\n\nconst tokenizer = require('./tokenizer.cjs');\n\nconst TAB = 9;\nconst N = 10;\nconst F = 12;\nconst R = 13;\nconst SPACE = 32;\nconst EXCLAMATIONMARK = 33;    // !\nconst NUMBERSIGN = 35;         // #\nconst AMPERSAND = 38;          // &\nconst APOSTROPHE = 39;         // '\nconst LEFTPARENTHESIS = 40;    // (\nconst RIGHTPARENTHESIS = 41;   // )\nconst ASTERISK = 42;           // *\nconst PLUSSIGN = 43;           // +\nconst COMMA = 44;              // ,\nconst HYPERMINUS = 45;         // -\nconst LESSTHANSIGN = 60;       // <\nconst GREATERTHANSIGN = 62;    // >\nconst QUESTIONMARK = 63;       // ?\nconst COMMERCIALAT = 64;       // @\nconst LEFTSQUAREBRACKET = 91;  // [\nconst RIGHTSQUAREBRACKET = 93; // ]\nconst LEFTCURLYBRACKET = 123;  // {\nconst VERTICALLINE = 124;      // |\nconst RIGHTCURLYBRACKET = 125; // }\nconst INFINITY = 8734;         // ∞\nconst NAME_CHAR = new Uint8Array(128).map((_, idx) =>\n    /[a-zA-Z0-9\\-]/.test(String.fromCharCode(idx)) ? 1 : 0\n);\nconst COMBINATOR_PRECEDENCE = {\n    ' ': 1,\n    '&&': 2,\n    '||': 3,\n    '|': 4\n};\n\nfunction scanSpaces(tokenizer) {\n    return tokenizer.substringToPos(\n        tokenizer.findWsEnd(tokenizer.pos)\n    );\n}\n\nfunction scanWord(tokenizer) {\n    let end = tokenizer.pos;\n\n    for (; end < tokenizer.str.length; end++) {\n        const code = tokenizer.str.charCodeAt(end);\n        if (code >= 128 || NAME_CHAR[code] === 0) {\n            break;\n        }\n    }\n\n    if (tokenizer.pos === end) {\n        tokenizer.error('Expect a keyword');\n    }\n\n    return tokenizer.substringToPos(end);\n}\n\nfunction scanNumber(tokenizer) {\n    let end = tokenizer.pos;\n\n    for (; end < tokenizer.str.length; end++) {\n        const code = tokenizer.str.charCodeAt(end);\n        if (code < 48 || code > 57) {\n            break;\n        }\n    }\n\n    if (tokenizer.pos === end) {\n        tokenizer.error('Expect a number');\n    }\n\n    return tokenizer.substringToPos(end);\n}\n\nfunction scanString(tokenizer) {\n    const end = tokenizer.str.indexOf('\\'', tokenizer.pos + 1);\n\n    if (end === -1) {\n        tokenizer.pos = tokenizer.str.length;\n        tokenizer.error('Expect an apostrophe');\n    }\n\n    return tokenizer.substringToPos(end + 1);\n}\n\nfunction readMultiplierRange(tokenizer) {\n    let min = null;\n    let max = null;\n\n    tokenizer.eat(LEFTCURLYBRACKET);\n\n    min = scanNumber(tokenizer);\n\n    if (tokenizer.charCode() === COMMA) {\n        tokenizer.pos++;\n        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {\n            max = scanNumber(tokenizer);\n        }\n    } else {\n        max = min;\n    }\n\n    tokenizer.eat(RIGHTCURLYBRACKET);\n\n    return {\n        min: Number(min),\n        max: max ? Number(max) : 0\n    };\n}\n\nfunction readMultiplier(tokenizer) {\n    let range = null;\n    let comma = false;\n\n    switch (tokenizer.charCode()) {\n        case ASTERISK:\n            tokenizer.pos++;\n\n            range = {\n                min: 0,\n                max: 0\n            };\n\n            break;\n\n        case PLUSSIGN:\n            tokenizer.pos++;\n\n            range = {\n                min: 1,\n                max: 0\n            };\n\n            break;\n\n        case QUESTIONMARK:\n            tokenizer.pos++;\n\n            range = {\n                min: 0,\n                max: 1\n            };\n\n            break;\n\n        case NUMBERSIGN:\n            tokenizer.pos++;\n\n            comma = true;\n\n            if (tokenizer.charCode() === LEFTCURLYBRACKET) {\n                range = readMultiplierRange(tokenizer);\n            } else if (tokenizer.charCode() === QUESTIONMARK) {\n                // https://www.w3.org/TR/css-values-4/#component-multipliers\n                // > the # and ? multipliers may be stacked as #?\n                // In this case just treat \"#?\" as a single multiplier\n                // { min: 0, max: 0, comma: true }\n                tokenizer.pos++;\n                range = {\n                    min: 0,\n                    max: 0\n                };\n            } else {\n                range = {\n                    min: 1,\n                    max: 0\n                };\n            }\n\n            break;\n\n        case LEFTCURLYBRACKET:\n            range = readMultiplierRange(tokenizer);\n            break;\n\n        default:\n            return null;\n    }\n\n    return {\n        type: 'Multiplier',\n        comma,\n        min: range.min,\n        max: range.max,\n        term: null\n    };\n}\n\nfunction maybeMultiplied(tokenizer, node) {\n    const multiplier = readMultiplier(tokenizer);\n\n    if (multiplier !== null) {\n        multiplier.term = node;\n\n        // https://www.w3.org/TR/css-values-4/#component-multipliers\n        // > The + and # multipliers may be stacked as +#;\n        // Represent \"+#\" as nested multipliers:\n        // { ...<multiplier #>,\n        //   term: {\n        //     ...<multipler +>,\n        //     term: node\n        //   }\n        // }\n        if (tokenizer.charCode() === NUMBERSIGN &&\n            tokenizer.charCodeAt(tokenizer.pos - 1) === PLUSSIGN) {\n            return maybeMultiplied(tokenizer, multiplier);\n        }\n\n        return multiplier;\n    }\n\n    return node;\n}\n\nfunction maybeToken(tokenizer) {\n    const ch = tokenizer.peek();\n\n    if (ch === '') {\n        return null;\n    }\n\n    return {\n        type: 'Token',\n        value: ch\n    };\n}\n\nfunction readProperty(tokenizer) {\n    let name;\n\n    tokenizer.eat(LESSTHANSIGN);\n    tokenizer.eat(APOSTROPHE);\n\n    name = scanWord(tokenizer);\n\n    tokenizer.eat(APOSTROPHE);\n    tokenizer.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Property',\n        name\n    });\n}\n\n// https://drafts.csswg.org/css-values-3/#numeric-ranges\n// 4.1. Range Restrictions and Range Definition Notation\n//\n// Range restrictions can be annotated in the numeric type notation using CSS bracketed\n// range notation—[min,max]—within the angle brackets, after the identifying keyword,\n// indicating a closed range between (and including) min and max.\n// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.\nfunction readTypeRange(tokenizer) {\n    // use null for Infinity to make AST format JSON serializable/deserializable\n    let min = null; // -Infinity\n    let max = null; // Infinity\n    let sign = 1;\n\n    tokenizer.eat(LEFTSQUAREBRACKET);\n\n    if (tokenizer.charCode() === HYPERMINUS) {\n        tokenizer.peek();\n        sign = -1;\n    }\n\n    if (sign == -1 && tokenizer.charCode() === INFINITY) {\n        tokenizer.peek();\n    } else {\n        min = sign * Number(scanNumber(tokenizer));\n\n        if (NAME_CHAR[tokenizer.charCode()] !== 0) {\n            min += scanWord(tokenizer);\n        }\n    }\n\n    scanSpaces(tokenizer);\n    tokenizer.eat(COMMA);\n    scanSpaces(tokenizer);\n\n    if (tokenizer.charCode() === INFINITY) {\n        tokenizer.peek();\n    } else {\n        sign = 1;\n\n        if (tokenizer.charCode() === HYPERMINUS) {\n            tokenizer.peek();\n            sign = -1;\n        }\n\n        max = sign * Number(scanNumber(tokenizer));\n\n        if (NAME_CHAR[tokenizer.charCode()] !== 0) {\n            max += scanWord(tokenizer);\n        }\n    }\n\n    tokenizer.eat(RIGHTSQUAREBRACKET);\n\n    return {\n        type: 'Range',\n        min,\n        max\n    };\n}\n\nfunction readType(tokenizer) {\n    let name;\n    let opts = null;\n\n    tokenizer.eat(LESSTHANSIGN);\n    name = scanWord(tokenizer);\n\n    if (tokenizer.charCode() === LEFTPARENTHESIS &&\n        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {\n        tokenizer.pos += 2;\n        name += '()';\n    }\n\n    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {\n        scanSpaces(tokenizer);\n        opts = readTypeRange(tokenizer);\n    }\n\n    tokenizer.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Type',\n        name,\n        opts\n    });\n}\n\nfunction readKeywordOrFunction(tokenizer) {\n    const name = scanWord(tokenizer);\n\n    if (tokenizer.charCode() === LEFTPARENTHESIS) {\n        tokenizer.pos++;\n\n        return {\n            type: 'Function',\n            name\n        };\n    }\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Keyword',\n        name\n    });\n}\n\nfunction regroupTerms(terms, combinators) {\n    function createGroup(terms, combinator) {\n        return {\n            type: 'Group',\n            terms,\n            combinator,\n            disallowEmpty: false,\n            explicit: false\n        };\n    }\n\n    let combinator;\n\n    combinators = Object.keys(combinators)\n        .sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);\n\n    while (combinators.length > 0) {\n        combinator = combinators.shift();\n\n        let i = 0;\n        let subgroupStart = 0;\n\n        for (; i < terms.length; i++) {\n            const term = terms[i];\n\n            if (term.type === 'Combinator') {\n                if (term.value === combinator) {\n                    if (subgroupStart === -1) {\n                        subgroupStart = i - 1;\n                    }\n                    terms.splice(i, 1);\n                    i--;\n                } else {\n                    if (subgroupStart !== -1 && i - subgroupStart > 1) {\n                        terms.splice(\n                            subgroupStart,\n                            i - subgroupStart,\n                            createGroup(terms.slice(subgroupStart, i), combinator)\n                        );\n                        i = subgroupStart + 1;\n                    }\n                    subgroupStart = -1;\n                }\n            }\n        }\n\n        if (subgroupStart !== -1 && combinators.length) {\n            terms.splice(\n                subgroupStart,\n                i - subgroupStart,\n                createGroup(terms.slice(subgroupStart, i), combinator)\n            );\n        }\n    }\n\n    return combinator;\n}\n\nfunction readImplicitGroup(tokenizer) {\n    const terms = [];\n    const combinators = {};\n    let token;\n    let prevToken = null;\n    let prevTokenPos = tokenizer.pos;\n\n    while (token = peek(tokenizer)) {\n        if (token.type !== 'Spaces') {\n            if (token.type === 'Combinator') {\n                // check for combinator in group beginning and double combinator sequence\n                if (prevToken === null || prevToken.type === 'Combinator') {\n                    tokenizer.pos = prevTokenPos;\n                    tokenizer.error('Unexpected combinator');\n                }\n\n                combinators[token.value] = true;\n            } else if (prevToken !== null && prevToken.type !== 'Combinator') {\n                combinators[' '] = true;  // a b\n                terms.push({\n                    type: 'Combinator',\n                    value: ' '\n                });\n            }\n\n            terms.push(token);\n            prevToken = token;\n            prevTokenPos = tokenizer.pos;\n        }\n    }\n\n    // check for combinator in group ending\n    if (prevToken !== null && prevToken.type === 'Combinator') {\n        tokenizer.pos -= prevTokenPos;\n        tokenizer.error('Unexpected combinator');\n    }\n\n    return {\n        type: 'Group',\n        terms,\n        combinator: regroupTerms(terms, combinators) || ' ',\n        disallowEmpty: false,\n        explicit: false\n    };\n}\n\nfunction readGroup(tokenizer) {\n    let result;\n\n    tokenizer.eat(LEFTSQUAREBRACKET);\n    result = readImplicitGroup(tokenizer);\n    tokenizer.eat(RIGHTSQUAREBRACKET);\n\n    result.explicit = true;\n\n    if (tokenizer.charCode() === EXCLAMATIONMARK) {\n        tokenizer.pos++;\n        result.disallowEmpty = true;\n    }\n\n    return result;\n}\n\nfunction peek(tokenizer) {\n    let code = tokenizer.charCode();\n\n    if (code < 128 && NAME_CHAR[code] === 1) {\n        return readKeywordOrFunction(tokenizer);\n    }\n\n    switch (code) {\n        case RIGHTSQUAREBRACKET:\n            // don't eat, stop scan a group\n            break;\n\n        case LEFTSQUAREBRACKET:\n            return maybeMultiplied(tokenizer, readGroup(tokenizer));\n\n        case LESSTHANSIGN:\n            return tokenizer.nextCharCode() === APOSTROPHE\n                ? readProperty(tokenizer)\n                : readType(tokenizer);\n\n        case VERTICALLINE:\n            return {\n                type: 'Combinator',\n                value: tokenizer.substringToPos(\n                    tokenizer.pos + (tokenizer.nextCharCode() === VERTICALLINE ? 2 : 1)\n                )\n            };\n\n        case AMPERSAND:\n            tokenizer.pos++;\n            tokenizer.eat(AMPERSAND);\n\n            return {\n                type: 'Combinator',\n                value: '&&'\n            };\n\n        case COMMA:\n            tokenizer.pos++;\n            return {\n                type: 'Comma'\n            };\n\n        case APOSTROPHE:\n            return maybeMultiplied(tokenizer, {\n                type: 'String',\n                value: scanString(tokenizer)\n            });\n\n        case SPACE:\n        case TAB:\n        case N:\n        case R:\n        case F:\n            return {\n                type: 'Spaces',\n                value: scanSpaces(tokenizer)\n            };\n\n        case COMMERCIALAT:\n            code = tokenizer.nextCharCode();\n\n            if (code < 128 && NAME_CHAR[code] === 1) {\n                tokenizer.pos++;\n                return {\n                    type: 'AtKeyword',\n                    name: scanWord(tokenizer)\n                };\n            }\n\n            return maybeToken(tokenizer);\n\n        case ASTERISK:\n        case PLUSSIGN:\n        case QUESTIONMARK:\n        case NUMBERSIGN:\n        case EXCLAMATIONMARK:\n            // prohibited tokens (used as a multiplier start)\n            break;\n\n        case LEFTCURLYBRACKET:\n            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting\n            // check next char isn't a number, because it's likely a disjoined multiplier\n            code = tokenizer.nextCharCode();\n\n            if (code < 48 || code > 57) {\n                return maybeToken(tokenizer);\n            }\n\n            break;\n\n        default:\n            return maybeToken(tokenizer);\n    }\n}\n\nfunction parse(source) {\n    const tokenizer$1 = new tokenizer.Tokenizer(source);\n    const result = readImplicitGroup(tokenizer$1);\n\n    if (tokenizer$1.pos !== source.length) {\n        tokenizer$1.error('Unexpected input');\n    }\n\n    // reduce redundant groups with single group term\n    if (result.terms.length === 1 && result.terms[0].type === 'Group') {\n        return result.terms[0];\n    }\n\n    return result;\n}\n\nexports.parse = parse;\n","'use strict';\n\nconst parse = require('../definition-syntax/parse.cjs');\n\nconst MATCH = { type: 'Match' };\nconst MISMATCH = { type: 'Mismatch' };\nconst DISALLOW_EMPTY = { type: 'DisallowEmpty' };\n\nconst LEFTPARENTHESIS = 40;  // (\nconst RIGHTPARENTHESIS = 41; // )\n\nfunction createCondition(match, thenBranch, elseBranch) {\n    // reduce node count\n    if (thenBranch === MATCH && elseBranch === MISMATCH) {\n        return match;\n    }\n\n    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n        return match;\n    }\n\n    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n        thenBranch = match.then;\n        match = match.match;\n    }\n\n    return {\n        type: 'If',\n        match,\n        then: thenBranch,\n        else: elseBranch\n    };\n}\n\nfunction isFunctionType(name) {\n    return (\n        name.length > 2 &&\n        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&\n        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS\n    );\n}\n\nfunction isEnumCapatible(term) {\n    return (\n        term.type === 'Keyword' ||\n        term.type === 'AtKeyword' ||\n        term.type === 'Function' ||\n        term.type === 'Type' && isFunctionType(term.name)\n    );\n}\n\nfunction buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n    switch (combinator) {\n        case ' ': {\n            // Juxtaposing components means that all of them must occur, in the given order.\n            //\n            // a b c\n            // =\n            // match a\n            //   then match b\n            //     then match c\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            //   else MISMATCH\n            let result = MATCH;\n\n            for (let i = terms.length - 1; i >= 0; i--) {\n                const term = terms[i];\n\n                result = createCondition(\n                    term,\n                    result,\n                    MISMATCH\n                );\n            }\n            return result;\n        }\n\n        case '|': {\n            // A bar (|) separates two or more alternatives: exactly one of them must occur.\n            //\n            // a | b | c\n            // =\n            // match a\n            //   then MATCH\n            //   else match b\n            //     then MATCH\n            //     else match c\n            //       then MATCH\n            //       else MISMATCH\n\n            let result = MISMATCH;\n            let map = null;\n\n            for (let i = terms.length - 1; i >= 0; i--) {\n                let term = terms[i];\n\n                // reduce sequence of keywords into a Enum\n                if (isEnumCapatible(term)) {\n                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n                        map = Object.create(null);\n                        result = createCondition(\n                            {\n                                type: 'Enum',\n                                map\n                            },\n                            MATCH,\n                            result\n                        );\n                    }\n\n                    if (map !== null) {\n                        const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n                        if (key in map === false) {\n                            map[key] = term;\n                            continue;\n                        }\n                    }\n                }\n\n                map = null;\n\n                // create a new conditonal node\n                result = createCondition(\n                    term,\n                    MATCH,\n                    result\n                );\n            }\n            return result;\n        }\n\n        case '&&': {\n            // A double ampersand (&&) separates two or more components,\n            // all of which must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since &&-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms,\n                    all: true\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a && b && c\n            // =\n            // match a\n            //   then [b && c]\n            //   else match b\n            //     then [a && c]\n            //     else match c\n            //       then [a && b]\n            //       else MISMATCH\n            //\n            // a && b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MISMATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            let result = MISMATCH;\n\n            for (let i = terms.length - 1; i >= 0; i--) {\n                const term = terms[i];\n                let thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        false\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            }\n            return result;\n        }\n\n        case '||': {\n            // A double bar (||) separates two or more options:\n            // one or more of them must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since ||-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms,\n                    all: false\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a || b || c\n            // =\n            // match a\n            //   then [b || c]\n            //   else match b\n            //     then [a || c]\n            //     else match c\n            //       then [a || b]\n            //       else MISMATCH\n            //\n            // a || b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MATCH\n            //     else MISMATCH\n            let result = atLeastOneTermMatched ? MATCH : MISMATCH;\n\n            for (let i = terms.length - 1; i >= 0; i--) {\n                const term = terms[i];\n                let thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        true\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            }\n            return result;\n        }\n    }\n}\n\nfunction buildMultiplierMatchGraph(node) {\n    let result = MATCH;\n    let matchTerm = buildMatchGraphInternal(node.term);\n\n    if (node.max === 0) {\n        // disable repeating of empty match to prevent infinite loop\n        matchTerm = createCondition(\n            matchTerm,\n            DISALLOW_EMPTY,\n            MISMATCH\n        );\n\n        // an occurrence count is not limited, make a cycle;\n        // to collect more terms on each following matching mismatch\n        result = createCondition(\n            matchTerm,\n            null, // will be a loop\n            MISMATCH\n        );\n\n        result.then = createCondition(\n            MATCH,\n            MATCH,\n            result // make a loop\n        );\n\n        if (node.comma) {\n            result.then.else = createCondition(\n                { type: 'Comma', syntax: node },\n                result,\n                MISMATCH\n            );\n        }\n    } else {\n        // create a match node chain for [min .. max] interval with optional matches\n        for (let i = node.min || 1; i <= node.max; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                createCondition(\n                    MATCH,\n                    MATCH,\n                    result\n                ),\n                MISMATCH\n            );\n        }\n    }\n\n    if (node.min === 0) {\n        // allow zero match\n        result = createCondition(\n            MATCH,\n            MATCH,\n            result\n        );\n    } else {\n        // create a match node chain to collect [0 ... min - 1] required matches\n        for (let i = 0; i < node.min - 1; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                result,\n                MISMATCH\n            );\n        }\n    }\n\n    return result;\n}\n\nfunction buildMatchGraphInternal(node) {\n    if (typeof node === 'function') {\n        return {\n            type: 'Generic',\n            fn: node\n        };\n    }\n\n    switch (node.type) {\n        case 'Group': {\n            let result = buildGroupMatchGraph(\n                node.combinator,\n                node.terms.map(buildMatchGraphInternal),\n                false\n            );\n\n            if (node.disallowEmpty) {\n                result = createCondition(\n                    result,\n                    DISALLOW_EMPTY,\n                    MISMATCH\n                );\n            }\n\n            return result;\n        }\n\n        case 'Multiplier':\n            return buildMultiplierMatchGraph(node);\n\n        case 'Type':\n        case 'Property':\n            return {\n                type: node.type,\n                name: node.name,\n                syntax: node\n            };\n\n        case 'Keyword':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'AtKeyword':\n            return {\n                type: node.type,\n                name: '@' + node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'Function':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase() + '(',\n                syntax: node\n            };\n\n        case 'String':\n            // convert a one char length String to a Token\n            if (node.value.length === 3) {\n                return {\n                    type: 'Token',\n                    value: node.value.charAt(1),\n                    syntax: node\n                };\n            }\n\n            // otherwise use it as is\n            return {\n                type: node.type,\n                value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n                syntax: node\n            };\n\n        case 'Token':\n            return {\n                type: node.type,\n                value: node.value,\n                syntax: node\n            };\n\n        case 'Comma':\n            return {\n                type: node.type,\n                syntax: node\n            };\n\n        default:\n            throw new Error('Unknown node type:', node.type);\n    }\n}\n\nfunction buildMatchGraph(syntaxTree, ref) {\n    if (typeof syntaxTree === 'string') {\n        syntaxTree = parse.parse(syntaxTree);\n    }\n\n    return {\n        type: 'MatchGraph',\n        match: buildMatchGraphInternal(syntaxTree),\n        syntax: ref || null,\n        source: syntaxTree\n    };\n}\n\nexports.DISALLOW_EMPTY = DISALLOW_EMPTY;\nexports.MATCH = MATCH;\nexports.MISMATCH = MISMATCH;\nexports.buildMatchGraph = buildMatchGraph;\n","'use strict';\n\nconst matchGraph = require('./match-graph.cjs');\nconst types = require('../tokenizer/types.cjs');\n\nconst { hasOwnProperty } = Object.prototype;\nconst STUB = 0;\nconst TOKEN = 1;\nconst OPEN_SYNTAX = 2;\nconst CLOSE_SYNTAX = 3;\n\nconst EXIT_REASON_MATCH = 'Match';\nconst EXIT_REASON_MISMATCH = 'Mismatch';\nconst EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\n\nconst ITERATION_LIMIT = 15000;\n\nfunction reverseList(list) {\n    let prev = null;\n    let next = null;\n    let item = list;\n\n    while (item !== null) {\n        next = item.prev;\n        item.prev = prev;\n        prev = item;\n        item = next;\n    }\n\n    return prev;\n}\n\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n    if (testStr.length !== referenceStr.length) {\n        return false;\n    }\n\n    for (let i = 0; i < testStr.length; i++) {\n        const referenceCode = referenceStr.charCodeAt(i);\n        let testCode = testStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n        if (testCode >= 0x0041 && testCode <= 0x005A) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction isContextEdgeDelim(token) {\n    if (token.type !== types.Delim) {\n        return false;\n    }\n\n    // Fix matching for unicode-range: U+30??, U+FF00-FF9F\n    // Probably we need to check out previous match instead\n    return token.value !== '?';\n}\n\nfunction isCommaContextStart(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === types.Comma ||\n        token.type === types.Function ||\n        token.type === types.LeftParenthesis ||\n        token.type === types.LeftSquareBracket ||\n        token.type === types.LeftCurlyBracket ||\n        isContextEdgeDelim(token)\n    );\n}\n\nfunction isCommaContextEnd(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === types.RightParenthesis ||\n        token.type === types.RightSquareBracket ||\n        token.type === types.RightCurlyBracket ||\n        (token.type === types.Delim && token.value === '/')\n    );\n}\n\nfunction internalMatch(tokens, state, syntaxes) {\n    function moveToNextToken() {\n        do {\n            tokenIndex++;\n            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n        } while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment));\n    }\n\n    function getNextToken(offset) {\n        const nextIndex = tokenIndex + offset;\n\n        return nextIndex < tokens.length ? tokens[nextIndex] : null;\n    }\n\n    function stateSnapshotFromSyntax(nextState, prev) {\n        return {\n            nextState,\n            matchStack,\n            syntaxStack,\n            thenStack,\n            tokenIndex,\n            prev\n        };\n    }\n\n    function pushThenStack(nextState) {\n        thenStack = {\n            nextState,\n            matchStack,\n            syntaxStack,\n            prev: thenStack\n        };\n    }\n\n    function pushElseStack(nextState) {\n        elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n    }\n\n    function addTokenToMatch() {\n        matchStack = {\n            type: TOKEN,\n            syntax: state.syntax,\n            token,\n            prev: matchStack\n        };\n\n        moveToNextToken();\n        syntaxStash = null;\n\n        if (tokenIndex > longestMatch) {\n            longestMatch = tokenIndex;\n        }\n    }\n\n    function openSyntax() {\n        syntaxStack = {\n            syntax: state.syntax,\n            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,\n            prev: syntaxStack\n        };\n\n        matchStack = {\n            type: OPEN_SYNTAX,\n            syntax: state.syntax,\n            token: matchStack.token,\n            prev: matchStack\n        };\n    }\n\n    function closeSyntax() {\n        if (matchStack.type === OPEN_SYNTAX) {\n            matchStack = matchStack.prev;\n        } else {\n            matchStack = {\n                type: CLOSE_SYNTAX,\n                syntax: syntaxStack.syntax,\n                token: matchStack.token,\n                prev: matchStack\n            };\n        }\n\n        syntaxStack = syntaxStack.prev;\n    }\n\n    let syntaxStack = null;\n    let thenStack = null;\n    let elseStack = null;\n\n    // null – stashing allowed, nothing stashed\n    // false – stashing disabled, nothing stashed\n    // anithing else – fail stashable syntaxes, some syntax stashed\n    let syntaxStash = null;\n\n    let iterationCount = 0; // count iterations and prevent infinite loop\n    let exitReason = null;\n\n    let token = null;\n    let tokenIndex = -1;\n    let longestMatch = 0;\n    let matchStack = {\n        type: STUB,\n        syntax: null,\n        token: null,\n        prev: null\n    };\n\n    moveToNextToken();\n\n    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n        // function mapList(list, fn) {\n        //     const result = [];\n        //     while (list) {\n        //         result.unshift(fn(list));\n        //         list = list.prev;\n        //     }\n        //     return result;\n        // }\n        // console.log('--\\n',\n        //     '#' + iterationCount,\n        //     require('util').inspect({\n        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n        //         token: token && token.value,\n        //         tokenIndex,\n        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n        //     }, { depth: null })\n        // );\n        switch (state.type) {\n            case 'Match':\n                if (thenStack === null) {\n                    // turn to MISMATCH when some tokens left unmatched\n                    if (token !== null) {\n                        // doesn't mismatch if just one token left and it's an IE hack\n                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\\\0' && token.value !== '\\\\9')) {\n                            state = matchGraph.MISMATCH;\n                            break;\n                        }\n                    }\n\n                    // break the main loop, return a result - MATCH\n                    exitReason = EXIT_REASON_MATCH;\n                    break;\n                }\n\n                // go to next syntax (`then` branch)\n                state = thenStack.nextState;\n\n                // check match is not empty\n                if (state === matchGraph.DISALLOW_EMPTY) {\n                    if (thenStack.matchStack === matchStack) {\n                        state = matchGraph.MISMATCH;\n                        break;\n                    } else {\n                        state = matchGraph.MATCH;\n                    }\n                }\n\n                // close syntax if needed\n                while (thenStack.syntaxStack !== syntaxStack) {\n                    closeSyntax();\n                }\n\n                // pop stack\n                thenStack = thenStack.prev;\n                break;\n\n            case 'Mismatch':\n                // when some syntax is stashed\n                if (syntaxStash !== null && syntaxStash !== false) {\n                    // there is no else branches or a branch reduce match stack\n                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n                        // restore state from the stash\n                        elseStack = syntaxStash;\n                        syntaxStash = false; // disable stashing\n                    }\n                } else if (elseStack === null) {\n                    // no else branches -> break the main loop\n                    // return a result - MISMATCH\n                    exitReason = EXIT_REASON_MISMATCH;\n                    break;\n                }\n\n                // go to next syntax (`else` branch)\n                state = elseStack.nextState;\n\n                // restore all the rest stack states\n                thenStack = elseStack.thenStack;\n                syntaxStack = elseStack.syntaxStack;\n                matchStack = elseStack.matchStack;\n                tokenIndex = elseStack.tokenIndex;\n                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n\n                // pop stack\n                elseStack = elseStack.prev;\n                break;\n\n            case 'MatchGraph':\n                state = state.match;\n                break;\n\n            case 'If':\n                // IMPORTANT: else stack push must go first,\n                // since it stores the state of thenStack before changes\n                if (state.else !== matchGraph.MISMATCH) {\n                    pushElseStack(state.else);\n                }\n\n                if (state.then !== matchGraph.MATCH) {\n                    pushThenStack(state.then);\n                }\n\n                state = state.match;\n                break;\n\n            case 'MatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state,\n                    index: 0,\n                    mask: 0\n                };\n                break;\n\n            case 'MatchOnceBuffer': {\n                const terms = state.syntax.terms;\n\n                if (state.index === terms.length) {\n                    // no matches at all or it's required all terms to be matched\n                    if (state.mask === 0 || state.syntax.all) {\n                        state = matchGraph.MISMATCH;\n                        break;\n                    }\n\n                    // a partial match is ok\n                    state = matchGraph.MATCH;\n                    break;\n                }\n\n                // all terms are matched\n                if (state.mask === (1 << terms.length) - 1) {\n                    state = matchGraph.MATCH;\n                    break;\n                }\n\n                for (; state.index < terms.length; state.index++) {\n                    const matchFlag = 1 << state.index;\n\n                    if ((state.mask & matchFlag) === 0) {\n                        // IMPORTANT: else stack push must go first,\n                        // since it stores the state of thenStack before changes\n                        pushElseStack(state);\n                        pushThenStack({\n                            type: 'AddMatchOnce',\n                            syntax: state.syntax,\n                            mask: state.mask | matchFlag\n                        });\n\n                        // match\n                        state = terms[state.index++];\n                        break;\n                    }\n                }\n                break;\n            }\n\n            case 'AddMatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state.syntax,\n                    index: 0,\n                    mask: state.mask\n                };\n                break;\n\n            case 'Enum':\n                if (token !== null) {\n                    let name = token.value.toLowerCase();\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (name.indexOf('\\\\') !== -1) {\n                        name = name.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (hasOwnProperty.call(state.map, name)) {\n                        state = state.map[name];\n                        break;\n                    }\n                }\n\n                state = matchGraph.MISMATCH;\n                break;\n\n            case 'Generic': {\n                const opts = syntaxStack !== null ? syntaxStack.opts : null;\n                const lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n\n                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = matchGraph.MATCH;\n                } else {\n                    state = matchGraph.MISMATCH;\n                }\n\n                break;\n            }\n\n            case 'Type':\n            case 'Property': {\n                const syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n                const dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n\n                if (!dictSyntax || !dictSyntax.match) {\n                    throw new Error(\n                        'Bad syntax reference: ' +\n                        (state.type === 'Type'\n                            ? '<' + state.name + '>'\n                            : '<\\'' + state.name + '\\'>')\n                    );\n                }\n\n                // stash a syntax for types with low priority\n                if (syntaxStash !== false && token !== null && state.type === 'Type') {\n                    const lowPriorityMatching =\n                        // https://drafts.csswg.org/css-values-4/#custom-idents\n                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n                        // can only claim the keyword if no other unfulfilled production can claim it.\n                        (state.name === 'custom-ident' && token.type === types.Ident) ||\n\n                        // https://drafts.csswg.org/css-values-4/#lengths\n                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n                        // it must parse as a <number>\n                        (state.name === 'length' && token.value === '0');\n\n                    if (lowPriorityMatching) {\n                        if (syntaxStash === null) {\n                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n                        }\n\n                        state = matchGraph.MISMATCH;\n                        break;\n                    }\n                }\n\n                openSyntax();\n                state = dictSyntax.match;\n                break;\n            }\n\n            case 'Keyword': {\n                const name = state.name;\n\n                if (token !== null) {\n                    let keywordName = token.value;\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (keywordName.indexOf('\\\\') !== -1) {\n                        keywordName = keywordName.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (areStringsEqualCaseInsensitive(keywordName, name)) {\n                        addTokenToMatch();\n                        state = matchGraph.MATCH;\n                        break;\n                    }\n                }\n\n                state = matchGraph.MISMATCH;\n                break;\n            }\n\n            case 'AtKeyword':\n            case 'Function':\n                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n                    addTokenToMatch();\n                    state = matchGraph.MATCH;\n                    break;\n                }\n\n                state = matchGraph.MISMATCH;\n                break;\n\n            case 'Token':\n                if (token !== null && token.value === state.value) {\n                    addTokenToMatch();\n                    state = matchGraph.MATCH;\n                    break;\n                }\n\n                state = matchGraph.MISMATCH;\n                break;\n\n            case 'Comma':\n                if (token !== null && token.type === types.Comma) {\n                    if (isCommaContextStart(matchStack.token)) {\n                        state = matchGraph.MISMATCH;\n                    } else {\n                        addTokenToMatch();\n                        state = isCommaContextEnd(token) ? matchGraph.MISMATCH : matchGraph.MATCH;\n                    }\n                } else {\n                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? matchGraph.MATCH : matchGraph.MISMATCH;\n                }\n\n                break;\n\n            case 'String':\n                let string = '';\n                let lastTokenIndex = tokenIndex;\n\n                for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n                    string += tokens[lastTokenIndex].value;\n                }\n\n                if (areStringsEqualCaseInsensitive(string, state.value)) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = matchGraph.MATCH;\n                } else {\n                    state = matchGraph.MISMATCH;\n                }\n\n                break;\n\n            default:\n                throw new Error('Unknown node type: ' + state.type);\n        }\n    }\n\n    switch (exitReason) {\n        case null:\n            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n            exitReason = EXIT_REASON_ITERATION_LIMIT;\n            matchStack = null;\n            break;\n\n        case EXIT_REASON_MATCH:\n            while (syntaxStack !== null) {\n                closeSyntax();\n            }\n            break;\n\n        default:\n            matchStack = null;\n    }\n\n    return {\n        tokens,\n        reason: exitReason,\n        iterations: iterationCount,\n        match: matchStack,\n        longestMatch\n    };\n}\n\nfunction matchAsList(tokens, matchGraph, syntaxes) {\n    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match !== null) {\n        let item = reverseList(matchResult.match).prev;\n\n        matchResult.match = [];\n\n        while (item !== null) {\n            switch (item.type) {\n                case OPEN_SYNTAX:\n                case CLOSE_SYNTAX:\n                    matchResult.match.push({\n                        type: item.type,\n                        syntax: item.syntax\n                    });\n                    break;\n\n                default:\n                    matchResult.match.push({\n                        token: item.token.value,\n                        node: item.token.node\n                    });\n                    break;\n            }\n\n            item = item.prev;\n        }\n    }\n\n    return matchResult;\n}\n\nfunction matchAsTree(tokens, matchGraph, syntaxes) {\n    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match === null) {\n        return matchResult;\n    }\n\n    let item = matchResult.match;\n    let host = matchResult.match = {\n        syntax: matchGraph.syntax || null,\n        match: []\n    };\n    const hostStack = [host];\n\n    // revert a list and start with 2nd item since 1st is a stub item\n    item = reverseList(item).prev;\n\n    // build a tree\n    while (item !== null) {\n        switch (item.type) {\n            case OPEN_SYNTAX:\n                host.match.push(host = {\n                    syntax: item.syntax,\n                    match: []\n                });\n                hostStack.push(host);\n                break;\n\n            case CLOSE_SYNTAX:\n                hostStack.pop();\n                host = hostStack[hostStack.length - 1];\n                break;\n\n            default:\n                host.match.push({\n                    syntax: item.syntax || null,\n                    token: item.token.value,\n                    node: item.token.node\n                });\n        }\n\n        item = item.prev;\n    }\n\n    return matchResult;\n}\n\nexports.matchAsList = matchAsList;\nexports.matchAsTree = matchAsTree;\n","'use strict';\n\nfunction getTrace(node) {\n    function shouldPutToTrace(syntax) {\n        if (syntax === null) {\n            return false;\n        }\n\n        return (\n            syntax.type === 'Type' ||\n            syntax.type === 'Property' ||\n            syntax.type === 'Keyword'\n        );\n    }\n\n    function hasMatch(matchNode) {\n        if (Array.isArray(matchNode.match)) {\n            // use for-loop for better perfomance\n            for (let i = 0; i < matchNode.match.length; i++) {\n                if (hasMatch(matchNode.match[i])) {\n                    if (shouldPutToTrace(matchNode.syntax)) {\n                        result.unshift(matchNode.syntax);\n                    }\n\n                    return true;\n                }\n            }\n        } else if (matchNode.node === node) {\n            result = shouldPutToTrace(matchNode.syntax)\n                ? [matchNode.syntax]\n                : [];\n\n            return true;\n        }\n\n        return false;\n    }\n\n    let result = null;\n\n    if (this.matched !== null) {\n        hasMatch(this.matched);\n    }\n\n    return result;\n}\n\nfunction isType(node, type) {\n    return testNode(this, node, match => match.type === 'Type' && match.name === type);\n}\n\nfunction isProperty(node, property) {\n    return testNode(this, node, match => match.type === 'Property' && match.name === property);\n}\n\nfunction isKeyword(node) {\n    return testNode(this, node, match => match.type === 'Keyword');\n}\n\nfunction testNode(match, node, fn) {\n    const trace = getTrace.call(match, node);\n\n    if (trace === null) {\n        return false;\n    }\n\n    return trace.some(fn);\n}\n\nexports.getTrace = getTrace;\nexports.isKeyword = isKeyword;\nexports.isProperty = isProperty;\nexports.isType = isType;\n","'use strict';\n\nconst List = require('../utils/List.cjs');\n\nfunction getFirstMatchNode(matchNode) {\n    if ('node' in matchNode) {\n        return matchNode.node;\n    }\n\n    return getFirstMatchNode(matchNode.match[0]);\n}\n\nfunction getLastMatchNode(matchNode) {\n    if ('node' in matchNode) {\n        return matchNode.node;\n    }\n\n    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);\n}\n\nfunction matchFragments(lexer, ast, match, type, name) {\n    function findFragments(matchNode) {\n        if (matchNode.syntax !== null &&\n            matchNode.syntax.type === type &&\n            matchNode.syntax.name === name) {\n            const start = getFirstMatchNode(matchNode);\n            const end = getLastMatchNode(matchNode);\n\n            lexer.syntax.walk(ast, function(node, item, list) {\n                if (node === start) {\n                    const nodes = new List.List();\n\n                    do {\n                        nodes.appendData(item.data);\n\n                        if (item.data === end) {\n                            break;\n                        }\n\n                        item = item.next;\n                    } while (item !== null);\n\n                    fragments.push({\n                        parent: list,\n                        nodes\n                    });\n                }\n            });\n        }\n\n        if (Array.isArray(matchNode.match)) {\n            matchNode.match.forEach(findFragments);\n        }\n    }\n\n    const fragments = [];\n\n    if (match.matched !== null) {\n        findFragments(match.matched);\n    }\n\n    return fragments;\n}\n\nexports.matchFragments = matchFragments;\n","'use strict';\n\nconst List = require('../utils/List.cjs');\n\nconst { hasOwnProperty } = Object.prototype;\n\nfunction isValidNumber(value) {\n    // Number.isInteger(value) && value >= 0\n    return (\n        typeof value === 'number' &&\n        isFinite(value) &&\n        Math.floor(value) === value &&\n        value >= 0\n    );\n}\n\nfunction isValidLocation(loc) {\n    return (\n        Boolean(loc) &&\n        isValidNumber(loc.offset) &&\n        isValidNumber(loc.line) &&\n        isValidNumber(loc.column)\n    );\n}\n\nfunction createNodeStructureChecker(type, fields) {\n    return function checkNode(node, warn) {\n        if (!node || node.constructor !== Object) {\n            return warn(node, 'Type of node should be an Object');\n        }\n\n        for (let key in node) {\n            let valid = true;\n\n            if (hasOwnProperty.call(node, key) === false) {\n                continue;\n            }\n\n            if (key === 'type') {\n                if (node.type !== type) {\n                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');\n                }\n            } else if (key === 'loc') {\n                if (node.loc === null) {\n                    continue;\n                } else if (node.loc && node.loc.constructor === Object) {\n                    if (typeof node.loc.source !== 'string') {\n                        key += '.source';\n                    } else if (!isValidLocation(node.loc.start)) {\n                        key += '.start';\n                    } else if (!isValidLocation(node.loc.end)) {\n                        key += '.end';\n                    } else {\n                        continue;\n                    }\n                }\n\n                valid = false;\n            } else if (fields.hasOwnProperty(key)) {\n                valid = false;\n\n                for (let i = 0; !valid && i < fields[key].length; i++) {\n                    const fieldType = fields[key][i];\n\n                    switch (fieldType) {\n                        case String:\n                            valid = typeof node[key] === 'string';\n                            break;\n\n                        case Boolean:\n                            valid = typeof node[key] === 'boolean';\n                            break;\n\n                        case null:\n                            valid = node[key] === null;\n                            break;\n\n                        default:\n                            if (typeof fieldType === 'string') {\n                                valid = node[key] && node[key].type === fieldType;\n                            } else if (Array.isArray(fieldType)) {\n                                valid = node[key] instanceof List.List;\n                            }\n                    }\n                }\n            } else {\n                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');\n            }\n\n            if (!valid) {\n                warn(node, 'Bad value for `' + type + '.' + key + '`');\n            }\n        }\n\n        for (const key in fields) {\n            if (hasOwnProperty.call(fields, key) &&\n                hasOwnProperty.call(node, key) === false) {\n                warn(node, 'Field `' + type + '.' + key + '` is missed');\n            }\n        }\n    };\n}\n\nfunction processStructure(name, nodeType) {\n    const structure = nodeType.structure;\n    const fields = {\n        type: String,\n        loc: true\n    };\n    const docs = {\n        type: '\"' + name + '\"'\n    };\n\n    for (const key in structure) {\n        if (hasOwnProperty.call(structure, key) === false) {\n            continue;\n        }\n\n        const docsTypes = [];\n        const fieldTypes = fields[key] = Array.isArray(structure[key])\n            ? structure[key].slice()\n            : [structure[key]];\n\n        for (let i = 0; i < fieldTypes.length; i++) {\n            const fieldType = fieldTypes[i];\n            if (fieldType === String || fieldType === Boolean) {\n                docsTypes.push(fieldType.name);\n            } else if (fieldType === null) {\n                docsTypes.push('null');\n            } else if (typeof fieldType === 'string') {\n                docsTypes.push('<' + fieldType + '>');\n            } else if (Array.isArray(fieldType)) {\n                docsTypes.push('List'); // TODO: use type enum\n            } else {\n                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');\n            }\n        }\n\n        docs[key] = docsTypes.join(' | ');\n    }\n\n    return {\n        docs,\n        check: createNodeStructureChecker(name, fields)\n    };\n}\n\nfunction getStructureFromConfig(config) {\n    const structure = {};\n\n    if (config.node) {\n        for (const name in config.node) {\n            if (hasOwnProperty.call(config.node, name)) {\n                const nodeType = config.node[name];\n\n                if (nodeType.structure) {\n                    structure[name] = processStructure(name, nodeType);\n                } else {\n                    throw new Error('Missed `structure` field in `' + name + '` node type definition');\n                }\n            }\n        }\n    }\n\n    return structure;\n}\n\nexports.getStructureFromConfig = getStructureFromConfig;\n","'use strict';\n\nconst noop = function() {};\n\nfunction ensureFunction(value) {\n    return typeof value === 'function' ? value : noop;\n}\n\nfunction walk(node, options, context) {\n    function walk(node) {\n        enter.call(context, node);\n\n        switch (node.type) {\n            case 'Group':\n                node.terms.forEach(walk);\n                break;\n\n            case 'Multiplier':\n                walk(node.term);\n                break;\n\n            case 'Type':\n            case 'Property':\n            case 'Keyword':\n            case 'AtKeyword':\n            case 'Function':\n            case 'String':\n            case 'Token':\n            case 'Comma':\n                break;\n\n            default:\n                throw new Error('Unknown type: ' + node.type);\n        }\n\n        leave.call(context, node);\n    }\n\n    let enter = noop;\n    let leave = noop;\n\n    if (typeof options === 'function') {\n        enter = options;\n    } else if (options) {\n        enter = ensureFunction(options.enter);\n        leave = ensureFunction(options.leave);\n    }\n\n    if (enter === noop && leave === noop) {\n        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n    }\n\n    walk(node);\n}\n\nexports.walk = walk;\n","'use strict';\n\nconst error = require('./error.cjs');\nconst names = require('../utils/names.cjs');\nconst genericConst = require('./generic-const.cjs');\nconst generic = require('./generic.cjs');\nconst units = require('./units.cjs');\nconst prepareTokens = require('./prepare-tokens.cjs');\nconst matchGraph = require('./match-graph.cjs');\nconst match = require('./match.cjs');\nconst trace = require('./trace.cjs');\nconst search = require('./search.cjs');\nconst structure = require('./structure.cjs');\nconst parse = require('../definition-syntax/parse.cjs');\nconst generate = require('../definition-syntax/generate.cjs');\nconst walk = require('../definition-syntax/walk.cjs');\n\nconst cssWideKeywordsSyntax = matchGraph.buildMatchGraph(genericConst.cssWideKeywords.join(' | '));\n\nfunction dumpMapSyntax(map, compact, syntaxAsAst) {\n    const result = {};\n\n    for (const name in map) {\n        if (map[name].syntax) {\n            result[name] = syntaxAsAst\n                ? map[name].syntax\n                : generate.generate(map[name].syntax, { compact });\n        }\n    }\n\n    return result;\n}\n\nfunction dumpAtruleMapSyntax(map, compact, syntaxAsAst) {\n    const result = {};\n\n    for (const [name, atrule] of Object.entries(map)) {\n        result[name] = {\n            prelude: atrule.prelude && (\n                syntaxAsAst\n                    ? atrule.prelude.syntax\n                    : generate.generate(atrule.prelude.syntax, { compact })\n            ),\n            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)\n        };\n    }\n\n    return result;\n}\n\nfunction valueHasVar(tokens) {\n    for (let i = 0; i < tokens.length; i++) {\n        if (tokens[i].value.toLowerCase() === 'var(') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction buildMatchResult(matched, error, iterations) {\n    return {\n        matched,\n        iterations,\n        error,\n        ...trace\n    };\n}\n\nfunction matchSyntax(lexer, syntax, value, useCssWideKeywords) {\n    const tokens = prepareTokens(value, lexer.syntax);\n    let result;\n\n    if (valueHasVar(tokens)) {\n        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n    }\n\n    if (useCssWideKeywords) {\n        result = match.matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);\n    }\n\n    if (!useCssWideKeywords || !result.match) {\n        result = match.matchAsTree(tokens, syntax.match, lexer);\n        if (!result.match) {\n            return buildMatchResult(\n                null,\n                new error.SyntaxMatchError(result.reason, syntax.syntax, value, result),\n                result.iterations\n            );\n        }\n    }\n\n    return buildMatchResult(result.match, null, result.iterations);\n}\n\nclass Lexer {\n    constructor(config, syntax, structure$1) {\n        this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;\n        this.syntax = syntax;\n        this.generic = false;\n        this.units = { ...units };\n        this.atrules = Object.create(null);\n        this.properties = Object.create(null);\n        this.types = Object.create(null);\n        this.structure = structure$1 || structure.getStructureFromConfig(config);\n\n        if (config) {\n            if (config.units) {\n                for (const group of Object.keys(units)) {\n                    if (Array.isArray(config.units[group])) {\n                        this.units[group] = config.units[group];\n                    }\n                }\n            }\n\n            if (config.types) {\n                for (const name in config.types) {\n                    this.addType_(name, config.types[name]);\n                }\n            }\n\n            if (config.generic) {\n                this.generic = true;\n                for (const [name, value] of Object.entries(generic.createGenericTypes(this.units))) {\n                    this.addType_(name, value);\n                }\n            }\n\n            if (config.atrules) {\n                for (const name in config.atrules) {\n                    this.addAtrule_(name, config.atrules[name]);\n                }\n            }\n\n            if (config.properties) {\n                for (const name in config.properties) {\n                    this.addProperty_(name, config.properties[name]);\n                }\n            }\n        }\n    }\n\n    checkStructure(ast) {\n        function collectWarning(node, message) {\n            warns.push({ node, message });\n        }\n\n        const structure = this.structure;\n        const warns = [];\n\n        this.syntax.walk(ast, function(node) {\n            if (structure.hasOwnProperty(node.type)) {\n                structure[node.type].check(node, collectWarning);\n            } else {\n                collectWarning(node, 'Unknown node type `' + node.type + '`');\n            }\n        });\n\n        return warns.length ? warns : false;\n    }\n\n    createDescriptor(syntax, type, name, parent = null) {\n        const ref = {\n            type,\n            name\n        };\n        const descriptor = {\n            type,\n            name,\n            parent,\n            serializable: typeof syntax === 'string' || (syntax && typeof syntax.type === 'string'),\n            syntax: null,\n            match: null\n        };\n\n        if (typeof syntax === 'function') {\n            descriptor.match = matchGraph.buildMatchGraph(syntax, ref);\n        } else {\n            if (typeof syntax === 'string') {\n                // lazy parsing on first access\n                Object.defineProperty(descriptor, 'syntax', {\n                    get() {\n                        Object.defineProperty(descriptor, 'syntax', {\n                            value: parse.parse(syntax)\n                        });\n\n                        return descriptor.syntax;\n                    }\n                });\n            } else {\n                descriptor.syntax = syntax;\n            }\n\n            // lazy graph build on first access\n            Object.defineProperty(descriptor, 'match', {\n                get() {\n                    Object.defineProperty(descriptor, 'match', {\n                        value: matchGraph.buildMatchGraph(descriptor.syntax, ref)\n                    });\n\n                    return descriptor.match;\n                }\n            });\n        }\n\n        return descriptor;\n    }\n    addAtrule_(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.atrules[name] = {\n            type: 'Atrule',\n            name: name,\n            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,\n            descriptors: syntax.descriptors\n                ? Object.keys(syntax.descriptors).reduce(\n                    (map, descName) => {\n                        map[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);\n                        return map;\n                    },\n                    Object.create(null)\n                )\n                : null\n        };\n    }\n    addProperty_(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n    }\n    addType_(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.types[name] = this.createDescriptor(syntax, 'Type', name);\n    }\n\n    checkAtruleName(atruleName) {\n        if (!this.getAtrule(atruleName)) {\n            return new error.SyntaxReferenceError('Unknown at-rule', '@' + atruleName);\n        }\n    }\n    checkAtrulePrelude(atruleName, prelude) {\n        const error = this.checkAtruleName(atruleName);\n\n        if (error) {\n            return error;\n        }\n\n        const atrule = this.getAtrule(atruleName);\n\n        if (!atrule.prelude && prelude) {\n            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');\n        }\n\n        if (atrule.prelude && !prelude) {\n            if (!matchSyntax(this, atrule.prelude, '', false).matched) {\n                return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');\n            }\n        }\n    }\n    checkAtruleDescriptorName(atruleName, descriptorName) {\n        const error$1 = this.checkAtruleName(atruleName);\n\n        if (error$1) {\n            return error$1;\n        }\n\n        const atrule = this.getAtrule(atruleName);\n        const descriptor = names.keyword(descriptorName);\n\n        if (!atrule.descriptors) {\n            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');\n        }\n\n        if (!atrule.descriptors[descriptor.name] &&\n            !atrule.descriptors[descriptor.basename]) {\n            return new error.SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);\n        }\n    }\n    checkPropertyName(propertyName) {\n        if (!this.getProperty(propertyName)) {\n            return new error.SyntaxReferenceError('Unknown property', propertyName);\n        }\n    }\n\n    matchAtrulePrelude(atruleName, prelude) {\n        const error = this.checkAtrulePrelude(atruleName, prelude);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        const atrule = this.getAtrule(atruleName);\n\n        if (!atrule.prelude) {\n            return buildMatchResult(null, null);\n        }\n\n        return matchSyntax(this, atrule.prelude, prelude || '', false);\n    }\n    matchAtruleDescriptor(atruleName, descriptorName, value) {\n        const error = this.checkAtruleDescriptorName(atruleName, descriptorName);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        const atrule = this.getAtrule(atruleName);\n        const descriptor = names.keyword(descriptorName);\n\n        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);\n    }\n    matchDeclaration(node) {\n        if (node.type !== 'Declaration') {\n            return buildMatchResult(null, new Error('Not a Declaration node'));\n        }\n\n        return this.matchProperty(node.property, node.value);\n    }\n    matchProperty(propertyName, value) {\n        // don't match syntax for a custom property at the moment\n        if (names.property(propertyName).custom) {\n            return buildMatchResult(null, new Error('Lexer matching doesn\\'t applicable for custom properties'));\n        }\n\n        const error = this.checkPropertyName(propertyName);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        return matchSyntax(this, this.getProperty(propertyName), value, true);\n    }\n    matchType(typeName, value) {\n        const typeSyntax = this.getType(typeName);\n\n        if (!typeSyntax) {\n            return buildMatchResult(null, new error.SyntaxReferenceError('Unknown type', typeName));\n        }\n\n        return matchSyntax(this, typeSyntax, value, false);\n    }\n    match(syntax, value) {\n        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n            return buildMatchResult(null, new error.SyntaxReferenceError('Bad syntax'));\n        }\n\n        if (typeof syntax === 'string' || !syntax.match) {\n            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n        }\n\n        return matchSyntax(this, syntax, value, false);\n    }\n\n    findValueFragments(propertyName, value, type, name) {\n        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n    }\n    findDeclarationValueFragments(declaration, type, name) {\n        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n    }\n    findAllFragments(ast, type, name) {\n        const result = [];\n\n        this.syntax.walk(ast, {\n            visit: 'Declaration',\n            enter: (declaration) => {\n                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n            }\n        });\n\n        return result;\n    }\n\n    getAtrule(atruleName, fallbackBasename = true) {\n        const atrule = names.keyword(atruleName);\n        const atruleEntry = atrule.vendor && fallbackBasename\n            ? this.atrules[atrule.name] || this.atrules[atrule.basename]\n            : this.atrules[atrule.name];\n\n        return atruleEntry || null;\n    }\n    getAtrulePrelude(atruleName, fallbackBasename = true) {\n        const atrule = this.getAtrule(atruleName, fallbackBasename);\n\n        return atrule && atrule.prelude || null;\n    }\n    getAtruleDescriptor(atruleName, name) {\n        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators\n            ? this.atrules[atruleName].declarators[name] || null\n            : null;\n    }\n    getProperty(propertyName, fallbackBasename = true) {\n        const property = names.property(propertyName);\n        const propertyEntry = property.vendor && fallbackBasename\n            ? this.properties[property.name] || this.properties[property.basename]\n            : this.properties[property.name];\n\n        return propertyEntry || null;\n    }\n    getType(name) {\n        return hasOwnProperty.call(this.types, name) ? this.types[name] : null;\n    }\n\n    validate() {\n        function validate(syntax, name, broken, descriptor) {\n            if (broken.has(name)) {\n                return broken.get(name);\n            }\n\n            broken.set(name, false);\n            if (descriptor.syntax !== null) {\n                walk.walk(descriptor.syntax, function(node) {\n                    if (node.type !== 'Type' && node.type !== 'Property') {\n                        return;\n                    }\n\n                    const map = node.type === 'Type' ? syntax.types : syntax.properties;\n                    const brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n\n                    if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {\n                        broken.set(name, true);\n                    }\n                }, this);\n            }\n        }\n\n        let brokenTypes = new Map();\n        let brokenProperties = new Map();\n\n        for (const key in this.types) {\n            validate(this, key, brokenTypes, this.types[key]);\n        }\n\n        for (const key in this.properties) {\n            validate(this, key, brokenProperties, this.properties[key]);\n        }\n\n        brokenTypes = [...brokenTypes.keys()].filter(name => brokenTypes.get(name));\n        brokenProperties = [...brokenProperties.keys()].filter(name => brokenProperties.get(name));\n\n        if (brokenTypes.length || brokenProperties.length) {\n            return {\n                types: brokenTypes,\n                properties: brokenProperties\n            };\n        }\n\n        return null;\n    }\n    dump(syntaxAsAst, pretty) {\n        return {\n            generic: this.generic,\n            units: this.units,\n            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),\n            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)\n        };\n    }\n    toString() {\n        return JSON.stringify(this.dump());\n    }\n}\n\nexports.Lexer = Lexer;\n","'use strict';\n\nfunction appendOrSet(a, b) {\n    if (typeof b === 'string' && /^\\s*\\|/.test(b)) {\n        return typeof a === 'string'\n            ? a + b\n            : b.replace(/^\\s*\\|\\s*/, '');\n    }\n\n    return b || null;\n}\n\nfunction sliceProps(obj, props) {\n    const result = Object.create(null);\n\n    for (const [key, value] of Object.entries(obj)) {\n        if (value) {\n            result[key] = {};\n            for (const prop of Object.keys(value)) {\n                if (props.includes(prop)) {\n                    result[key][prop] = value[prop];\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction mix(dest, src) {\n    const result = { ...dest };\n\n    for (const [prop, value] of Object.entries(src)) {\n        switch (prop) {\n            case 'generic':\n                result[prop] = Boolean(value);\n                break;\n\n            case 'units':\n                result[prop] = { ...dest[prop] };\n                for (const [name, patch] of Object.entries(value)) {\n                    result[prop][name] = Array.isArray(patch) ? patch : [];\n                }\n                break;\n\n            case 'atrules':\n                result[prop] = { ...dest[prop] };\n\n                for (const [name, atrule] of Object.entries(value)) {\n                    const exists = result[prop][name] || {};\n                    const current = result[prop][name] = {\n                        prelude: exists.prelude || null,\n                        descriptors: {\n                            ...exists.descriptors\n                        }\n                    };\n\n                    if (!atrule) {\n                        continue;\n                    }\n\n                    current.prelude = atrule.prelude\n                        ? appendOrSet(current.prelude, atrule.prelude)\n                        : current.prelude || null;\n\n                    for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {\n                        current.descriptors[descriptorName] = descriptorValue\n                            ? appendOrSet(current.descriptors[descriptorName], descriptorValue)\n                            : null;\n                    }\n\n                    if (!Object.keys(current.descriptors).length) {\n                        current.descriptors = null;\n                    }\n                }\n                break;\n\n            case 'types':\n            case 'properties':\n                result[prop] = { ...dest[prop] };\n                for (const [name, syntax] of Object.entries(value)) {\n                    result[prop][name] = appendOrSet(result[prop][name], syntax);\n                }\n                break;\n\n            case 'scope':\n                result[prop] = { ...dest[prop] };\n                for (const [name, props] of Object.entries(value)) {\n                    result[prop][name] = { ...result[prop][name], ...props };\n                }\n                break;\n\n            case 'parseContext':\n                result[prop] = {\n                    ...dest[prop],\n                    ...value\n                };\n                break;\n\n            case 'atrule':\n            case 'pseudo':\n                result[prop] = {\n                    ...dest[prop],\n                    ...sliceProps(value, ['parse']) };\n                break;\n\n            case 'node':\n                result[prop] = {\n                    ...dest[prop],\n                    ...sliceProps(value, ['name', 'structure', 'parse', 'generate', 'walkContext'])\n                };\n                break;\n        }\n    }\n\n    return result;\n}\n\nmodule.exports = mix;\n","'use strict';\n\nconst index = require('../tokenizer/index.cjs');\nconst create = require('../parser/create.cjs');\nconst create$2 = require('../generator/create.cjs');\nconst create$3 = require('../convertor/create.cjs');\nconst create$1 = require('../walker/create.cjs');\nconst Lexer = require('../lexer/Lexer.cjs');\nconst mix = require('./config/mix.cjs');\n\nfunction createSyntax(config) {\n    const parse = create.createParser(config);\n    const walk = create$1.createWalker(config);\n    const generate = create$2.createGenerator(config);\n    const { fromPlainObject, toPlainObject } = create$3.createConvertor(walk);\n\n    const syntax = {\n        lexer: null,\n        createLexer: config => new Lexer.Lexer(config, syntax, syntax.lexer.structure),\n\n        tokenize: index.tokenize,\n        parse,\n        generate,\n\n        walk,\n        find: walk.find,\n        findLast: walk.findLast,\n        findAll: walk.findAll,\n\n        fromPlainObject,\n        toPlainObject,\n\n        fork(extension) {\n            const base = mix({}, config); // copy of config\n\n            return createSyntax(\n                typeof extension === 'function'\n                    ? extension(base, Object.assign)\n                    : mix(base, extension)\n            );\n        }\n    };\n\n    syntax.lexer = new Lexer.Lexer({\n        generic: true,\n        units: config.units,\n        types: config.types,\n        atrules: config.atrules,\n        properties: config.properties,\n        node: config.node\n    }, syntax);\n\n    return syntax;\n}\nconst createSyntax$1 = config => createSyntax(mix({}, config));\n\nmodule.exports = createSyntax$1;\n","'use strict';\n\nconst dataPatch = require('./data-patch.cjs');\n\nconst mdnAtrules = require('mdn-data/css/at-rules.json');\nconst mdnProperties = require('mdn-data/css/properties.json');\nconst mdnSyntaxes = require('mdn-data/css/syntaxes.json');\n\nconst extendSyntax = /^\\s*\\|\\s*/;\n\nfunction preprocessAtrules(dict) {\n    const result = Object.create(null);\n\n    for (const atruleName in dict) {\n        const atrule = dict[atruleName];\n        let descriptors = null;\n\n        if (atrule.descriptors) {\n            descriptors = Object.create(null);\n\n            for (const descriptor in atrule.descriptors) {\n                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;\n            }\n        }\n\n        result[atruleName.substr(1)] = {\n            prelude: atrule.syntax.trim().replace(/\\{(.|\\s)+\\}/, '').match(/^@\\S+\\s+([^;\\{]*)/)[1].trim() || null,\n            descriptors\n        };\n    }\n\n    return result;\n}\n\nfunction patchDictionary(dict, patchDict) {\n    const result = {};\n\n    // copy all syntaxes for an original dict\n    for (const key in dict) {\n        result[key] = dict[key].syntax || dict[key];\n    }\n\n    // apply a patch\n    for (const key in patchDict) {\n        if (key in dict) {\n            if (patchDict[key].syntax) {\n                result[key] = extendSyntax.test(patchDict[key].syntax)\n                    ? result[key] + ' ' + patchDict[key].syntax.trim()\n                    : patchDict[key].syntax;\n            } else {\n                delete result[key];\n            }\n        } else {\n            if (patchDict[key].syntax) {\n                result[key] = patchDict[key].syntax.replace(extendSyntax, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction patchAtrules(dict, patchDict) {\n    const result = {};\n\n    // copy all syntaxes for an original dict\n    for (const key in dict) {\n        const atrulePatch = patchDict[key] || {};\n\n        result[key] = {\n            prelude: key in patchDict && 'prelude' in atrulePatch\n                ? atrulePatch.prelude\n                : dict[key].prelude || null,\n            descriptors: patchDictionary(dict[key].descriptors || {}, atrulePatch.descriptors || {})\n        };\n    }\n\n    // apply a patch\n    for (const key in patchDict) {\n        if (!hasOwnProperty.call(dict, key)) {\n            const atrulePatch = patchDict[key] || {};\n\n            result[key] = {\n                prelude: atrulePatch.prelude || null,\n                descriptors: atrulePatch.descriptors && patchDictionary({}, atrulePatch.descriptors)\n            };\n        }\n    }\n\n    return result;\n}\n\nconst definitions = {\n    types: patchDictionary(mdnSyntaxes, dataPatch.types),\n    atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),\n    properties: patchDictionary(mdnProperties, dataPatch.properties)\n};\n\nmodule.exports = definitions;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\nconst charCodeDefinitions = require('../../tokenizer/char-code-definitions.cjs');\n\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)\nconst DISALLOW_SIGN = true;\nconst ALLOW_SIGN = false;\n\nfunction checkInteger(offset, disallowSign) {\n    let pos = this.tokenStart + offset;\n    const code = this.charCodeAt(pos);\n\n    if (code === PLUSSIGN || code === HYPHENMINUS) {\n        if (disallowSign) {\n            this.error('Number sign is not allowed');\n        }\n        pos++;\n    }\n\n    for (; pos < this.tokenEnd; pos++) {\n        if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {\n            this.error('Integer is expected', pos);\n        }\n    }\n}\n\nfunction checkTokenIsInteger(disallowSign) {\n    return checkInteger.call(this, 0, disallowSign);\n}\n\nfunction expectCharCode(offset, code) {\n    if (!this.cmpChar(this.tokenStart + offset, code)) {\n        let msg = '';\n\n        switch (code) {\n            case N:\n                msg = 'N is expected';\n                break;\n            case HYPHENMINUS:\n                msg = 'HyphenMinus is expected';\n                break;\n        }\n\n        this.error(msg, this.tokenStart + offset);\n    }\n}\n\n// ... <signed-integer>\n// ... ['+' | '-'] <signless-integer>\nfunction consumeB() {\n    let offset = 0;\n    let sign = 0;\n    let type = this.tokenType;\n\n    while (type === types.WhiteSpace || type === types.Comment) {\n        type = this.lookupType(++offset);\n    }\n\n    if (type !== types.Number) {\n        if (this.isDelim(PLUSSIGN, offset) ||\n            this.isDelim(HYPHENMINUS, offset)) {\n            sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;\n\n            do {\n                type = this.lookupType(++offset);\n            } while (type === types.WhiteSpace || type === types.Comment);\n\n            if (type !== types.Number) {\n                this.skip(offset);\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    if (offset > 0) {\n        this.skip(offset);\n    }\n\n    if (sign === 0) {\n        type = this.charCodeAt(this.tokenStart);\n        if (type !== PLUSSIGN && type !== HYPHENMINUS) {\n            this.error('Number sign is expected');\n        }\n    }\n\n    checkTokenIsInteger.call(this, sign !== 0);\n    return sign === HYPHENMINUS ? '-' + this.consume(types.Number) : this.consume(types.Number);\n}\n\n// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\nconst name = 'AnPlusB';\nconst structure = {\n    a: [String, null],\n    b: [String, null]\n};\n\nfunction parse() {\n    /* eslint-disable brace-style*/\n    const start = this.tokenStart;\n    let a = null;\n    let b = null;\n\n    // <integer>\n    if (this.tokenType === types.Number) {\n        checkTokenIsInteger.call(this, ALLOW_SIGN);\n        b = this.consume(types.Number);\n    }\n\n    // -n\n    // -n <signed-integer>\n    // -n ['+' | '-'] <signless-integer>\n    // -n- <signless-integer>\n    // <dashndashdigit-ident>\n    else if (this.tokenType === types.Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {\n        a = '-1';\n\n        expectCharCode.call(this, 1, N);\n\n        switch (this.tokenEnd - this.tokenStart) {\n            // -n\n            // -n <signed-integer>\n            // -n ['+' | '-'] <signless-integer>\n            case 2:\n                this.next();\n                b = consumeB.call(this);\n                break;\n\n            // -n- <signless-integer>\n            case 3:\n                expectCharCode.call(this, 2, HYPHENMINUS);\n\n                this.next();\n                this.skipSC();\n\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n\n                b = '-' + this.consume(types.Number);\n                break;\n\n            // <dashndashdigit-ident>\n            default:\n                expectCharCode.call(this, 2, HYPHENMINUS);\n                checkInteger.call(this, 3, DISALLOW_SIGN);\n                this.next();\n\n                b = this.substrToCursor(start + 2);\n        }\n    }\n\n    // '+'? n\n    // '+'? n <signed-integer>\n    // '+'? n ['+' | '-'] <signless-integer>\n    // '+'? n- <signless-integer>\n    // '+'? <ndashdigit-ident>\n    else if (this.tokenType === types.Ident || (this.isDelim(PLUSSIGN) && this.lookupType(1) === types.Ident)) {\n        let sign = 0;\n        a = '1';\n\n        // just ignore a plus\n        if (this.isDelim(PLUSSIGN)) {\n            sign = 1;\n            this.next();\n        }\n\n        expectCharCode.call(this, 0, N);\n\n        switch (this.tokenEnd - this.tokenStart) {\n            // '+'? n\n            // '+'? n <signed-integer>\n            // '+'? n ['+' | '-'] <signless-integer>\n            case 1:\n                this.next();\n                b = consumeB.call(this);\n                break;\n\n            // '+'? n- <signless-integer>\n            case 2:\n                expectCharCode.call(this, 1, HYPHENMINUS);\n\n                this.next();\n                this.skipSC();\n\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n\n                b = '-' + this.consume(types.Number);\n                break;\n\n            // '+'? <ndashdigit-ident>\n            default:\n                expectCharCode.call(this, 1, HYPHENMINUS);\n                checkInteger.call(this, 2, DISALLOW_SIGN);\n                this.next();\n\n                b = this.substrToCursor(start + sign + 1);\n        }\n    }\n\n    // <ndashdigit-dimension>\n    // <ndash-dimension> <signless-integer>\n    // <n-dimension>\n    // <n-dimension> <signed-integer>\n    // <n-dimension> ['+' | '-'] <signless-integer>\n    else if (this.tokenType === types.Dimension) {\n        const code = this.charCodeAt(this.tokenStart);\n        const sign = code === PLUSSIGN || code === HYPHENMINUS;\n        let i = this.tokenStart + sign;\n\n        for (; i < this.tokenEnd; i++) {\n            if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {\n                break;\n            }\n        }\n\n        if (i === this.tokenStart + sign) {\n            this.error('Integer is expected', this.tokenStart + sign);\n        }\n\n        expectCharCode.call(this, i - this.tokenStart, N);\n        a = this.substring(start, i);\n\n        // <n-dimension>\n        // <n-dimension> <signed-integer>\n        // <n-dimension> ['+' | '-'] <signless-integer>\n        if (i + 1 === this.tokenEnd) {\n            this.next();\n            b = consumeB.call(this);\n        } else {\n            expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);\n\n            // <ndash-dimension> <signless-integer>\n            if (i + 2 === this.tokenEnd) {\n                this.next();\n                this.skipSC();\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n                b = '-' + this.consume(types.Number);\n            }\n            // <ndashdigit-dimension>\n            else {\n                checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);\n                this.next();\n                b = this.substrToCursor(i + 1);\n            }\n        }\n    } else {\n        this.error();\n    }\n\n    if (a !== null && a.charCodeAt(0) === PLUSSIGN) {\n        a = a.substr(1);\n    }\n\n    if (b !== null && b.charCodeAt(0) === PLUSSIGN) {\n        b = b.substr(1);\n    }\n\n    return {\n        type: 'AnPlusB',\n        loc: this.getLocation(start, this.tokenStart),\n        a,\n        b\n    };\n}\n\nfunction generate(node) {\n    if (node.a) {\n        const a =\n            node.a === '+1' && 'n' ||\n            node.a ===  '1' && 'n' ||\n            node.a === '-1' && '-n' ||\n            node.a + 'n';\n\n        if (node.b) {\n            const b = node.b[0] === '-' || node.b[0] === '+'\n                ? node.b\n                : '+' + node.b;\n            this.tokenize(a + b);\n        } else {\n            this.tokenize(a);\n        }\n    } else {\n        this.tokenize(node.b);\n    }\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nfunction consumeRaw(startToken) {\n    return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);\n}\n\nfunction isDeclarationBlockAtrule() {\n    for (let offset = 1, type; type = this.lookupType(offset); offset++) {\n        if (type === types.RightCurlyBracket) {\n            return true;\n        }\n\n        if (type === types.LeftCurlyBracket ||\n            type === types.AtKeyword) {\n            return false;\n        }\n    }\n\n    return false;\n}\n\n\nconst name = 'Atrule';\nconst walkContext = 'atrule';\nconst structure = {\n    name: String,\n    prelude: ['AtrulePrelude', 'Raw', null],\n    block: ['Block', null]\n};\n\nfunction parse(isDeclaration = false) {\n    const start = this.tokenStart;\n    let name;\n    let nameLowerCase;\n    let prelude = null;\n    let block = null;\n\n    this.eat(types.AtKeyword);\n\n    name = this.substrToCursor(start + 1);\n    nameLowerCase = name.toLowerCase();\n    this.skipSC();\n\n    // parse prelude\n    if (this.eof === false &&\n        this.tokenType !== types.LeftCurlyBracket &&\n        this.tokenType !== types.Semicolon) {\n        if (this.parseAtrulePrelude) {\n            prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name, isDeclaration), consumeRaw);\n        } else {\n            prelude = consumeRaw.call(this, this.tokenIndex);\n        }\n\n        this.skipSC();\n    }\n\n    switch (this.tokenType) {\n        case types.Semicolon:\n            this.next();\n            break;\n\n        case types.LeftCurlyBracket:\n            if (hasOwnProperty.call(this.atrule, nameLowerCase) &&\n                typeof this.atrule[nameLowerCase].block === 'function') {\n                block = this.atrule[nameLowerCase].block.call(this, isDeclaration);\n            } else {\n                // TODO: should consume block content as Raw?\n                block = this.Block(isDeclarationBlockAtrule.call(this));\n            }\n\n            break;\n    }\n\n    return {\n        type: 'Atrule',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        prelude,\n        block\n    };\n}\n\nfunction generate(node) {\n    this.token(types.AtKeyword, '@' + node.name);\n\n    if (node.prelude !== null) {\n        this.node(node.prelude);\n    }\n\n    if (node.block) {\n        this.node(node.block);\n    } else {\n        this.token(types.Semicolon, ';');\n    }\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.walkContext = walkContext;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'AtrulePrelude';\nconst walkContext = 'atrulePrelude';\nconst structure = {\n    children: [[]]\n};\n\nfunction parse(name) {\n    let children = null;\n\n    if (name !== null) {\n        name = name.toLowerCase();\n    }\n\n    this.skipSC();\n\n    if (hasOwnProperty.call(this.atrule, name) &&\n        typeof this.atrule[name].prelude === 'function') {\n        // custom consumer\n        children = this.atrule[name].prelude.call(this);\n    } else {\n        // default consumer\n        children = this.readSequence(this.scope.AtrulePrelude);\n    }\n\n    this.skipSC();\n\n    if (this.eof !== true &&\n        this.tokenType !== types.LeftCurlyBracket &&\n        this.tokenType !== types.Semicolon) {\n        this.error('Semicolon or block is expected');\n    }\n\n    return {\n        type: 'AtrulePrelude',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.children(node);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.walkContext = walkContext;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)\nconst ASTERISK = 0x002A;         // U+002A ASTERISK (*)\nconst EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)\nconst CIRCUMFLEXACCENT = 0x005E; // U+005E (^)\nconst VERTICALLINE = 0x007C;     // U+007C VERTICAL LINE (|)\nconst TILDE = 0x007E;            // U+007E TILDE (~)\n\nfunction getAttributeName() {\n    if (this.eof) {\n        this.error('Unexpected end of input');\n    }\n\n    const start = this.tokenStart;\n    let expectIdent = false;\n\n    if (this.isDelim(ASTERISK)) {\n        expectIdent = true;\n        this.next();\n    } else if (!this.isDelim(VERTICALLINE)) {\n        this.eat(types.Ident);\n    }\n\n    if (this.isDelim(VERTICALLINE)) {\n        if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {\n            this.next();\n            this.eat(types.Ident);\n        } else if (expectIdent) {\n            this.error('Identifier is expected', this.tokenEnd);\n        }\n    } else if (expectIdent) {\n        this.error('Vertical line is expected');\n    }\n\n    return {\n        type: 'Identifier',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start)\n    };\n}\n\nfunction getOperator() {\n    const start = this.tokenStart;\n    const code = this.charCodeAt(start);\n\n    if (code !== EQUALSSIGN &&        // =\n        code !== TILDE &&             // ~=\n        code !== CIRCUMFLEXACCENT &&  // ^=\n        code !== DOLLARSIGN &&        // $=\n        code !== ASTERISK &&          // *=\n        code !== VERTICALLINE         // |=\n    ) {\n        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');\n    }\n\n    this.next();\n\n    if (code !== EQUALSSIGN) {\n        if (!this.isDelim(EQUALSSIGN)) {\n            this.error('Equal sign is expected');\n        }\n\n        this.next();\n    }\n\n    return this.substrToCursor(start);\n}\n\n// '[' <wq-name> ']'\n// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'\nconst name = 'AttributeSelector';\nconst structure = {\n    name: 'Identifier',\n    matcher: [String, null],\n    value: ['String', 'Identifier', null],\n    flags: [String, null]\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n    let name;\n    let matcher = null;\n    let value = null;\n    let flags = null;\n\n    this.eat(types.LeftSquareBracket);\n    this.skipSC();\n\n    name = getAttributeName.call(this);\n    this.skipSC();\n\n    if (this.tokenType !== types.RightSquareBracket) {\n        // avoid case `[name i]`\n        if (this.tokenType !== types.Ident) {\n            matcher = getOperator.call(this);\n\n            this.skipSC();\n\n            value = this.tokenType === types.String\n                ? this.String()\n                : this.Identifier();\n\n            this.skipSC();\n        }\n\n        // attribute flags\n        if (this.tokenType === types.Ident) {\n            flags = this.consume(types.Ident);\n\n            this.skipSC();\n        }\n    }\n\n    this.eat(types.RightSquareBracket);\n\n    return {\n        type: 'AttributeSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        matcher,\n        value,\n        flags\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Delim, '[');\n    this.node(node.name);\n\n    if (node.matcher !== null) {\n        this.tokenize(node.matcher);\n        this.node(node.value);\n    }\n\n    if (node.flags !== null) {\n        this.token(types.Ident, node.flags);\n    }\n\n    this.token(types.Delim, ']');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nfunction consumeRaw(startToken) {\n    return this.Raw(startToken, null, true);\n}\nfunction consumeRule() {\n    return this.parseWithFallback(this.Rule, consumeRaw);\n}\nfunction consumeRawDeclaration(startToken) {\n    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);\n}\nfunction consumeDeclaration() {\n    if (this.tokenType === types.Semicolon) {\n        return consumeRawDeclaration.call(this, this.tokenIndex);\n    }\n\n    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);\n\n    if (this.tokenType === types.Semicolon) {\n        this.next();\n    }\n\n    return node;\n}\n\nconst name = 'Block';\nconst walkContext = 'block';\nconst structure = {\n    children: [[\n        'Atrule',\n        'Rule',\n        'Declaration'\n    ]]\n};\n\nfunction parse(isStyleBlock) {\n    const consumer = isStyleBlock ? consumeDeclaration : consumeRule;\n    const start = this.tokenStart;\n    let children = this.createList();\n\n    this.eat(types.LeftCurlyBracket);\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case types.RightCurlyBracket:\n                break scan;\n\n            case types.WhiteSpace:\n            case types.Comment:\n                this.next();\n                break;\n\n            case types.AtKeyword:\n                children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw));\n                break;\n\n            default:\n                if (isStyleBlock && this.isDelim(AMPERSAND))  {\n                    children.push(consumeRule.call(this));\n                } else {\n                    children.push(consumer.call(this));\n                }\n        }\n    }\n\n    if (!this.eof) {\n        this.eat(types.RightCurlyBracket);\n    }\n\n    return {\n        type: 'Block',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.token(types.LeftCurlyBracket, '{');\n    this.children(node, prev => {\n        if (prev.type === 'Declaration') {\n            this.token(types.Semicolon, ';');\n        }\n    });\n    this.token(types.RightCurlyBracket, '}');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.walkContext = walkContext;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'Brackets';\nconst structure = {\n    children: [[]]\n};\n\nfunction parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    let children = null;\n\n    this.eat(types.LeftSquareBracket);\n\n    children = readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(types.RightSquareBracket);\n    }\n\n    return {\n        type: 'Brackets',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Delim, '[');\n    this.children(node);\n    this.token(types.Delim, ']');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'CDC';\nconst structure = [];\n\nfunction parse() {\n    const start = this.tokenStart;\n\n    this.eat(types.CDC); // -->\n\n    return {\n        type: 'CDC',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nfunction generate() {\n    this.token(types.CDC, '-->');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'CDO';\nconst structure = [];\n\nfunction parse() {\n    const start = this.tokenStart;\n\n    this.eat(types.CDO); // <!--\n\n    return {\n        type: 'CDO',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nfunction generate() {\n    this.token(types.CDO, '<!--');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\n// '.' ident\nconst name = 'ClassSelector';\nconst structure = {\n    name: String\n};\n\nfunction parse() {\n    this.eatDelim(FULLSTOP);\n\n    return {\n        type: 'ClassSelector',\n        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),\n        name: this.consume(types.Ident)\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Delim, '.');\n    this.token(types.Ident, node.name);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\nconst TILDE = 0x007E;           // U+007E TILDE (~)\n\nconst name = 'Combinator';\nconst structure = {\n    name: String\n};\n\n// + | > | ~ | /deep/\nfunction parse() {\n    const start = this.tokenStart;\n    let name;\n\n    switch (this.tokenType) {\n        case types.WhiteSpace:\n            name = ' ';\n            break;\n\n        case types.Delim:\n            switch (this.charCodeAt(this.tokenStart)) {\n                case GREATERTHANSIGN:\n                case PLUSSIGN:\n                case TILDE:\n                    this.next();\n                    break;\n\n                case SOLIDUS:\n                    this.next();\n                    this.eatIdent('deep');\n                    this.eatDelim(SOLIDUS);\n                    break;\n\n                default:\n                    this.error('Combinator is expected');\n            }\n\n            name = this.substrToCursor(start);\n            break;\n    }\n\n    return {\n        type: 'Combinator',\n        loc: this.getLocation(start, this.tokenStart),\n        name\n    };\n}\n\nfunction generate(node) {\n    this.tokenize(node.name);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n\n\nconst name = 'Comment';\nconst structure = {\n    value: String\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n    let end = this.tokenEnd;\n\n    this.eat(types.Comment);\n\n    if ((end - start + 2) >= 2 &&\n        this.charCodeAt(end - 2) === ASTERISK &&\n        this.charCodeAt(end - 1) === SOLIDUS) {\n        end -= 2;\n    }\n\n    return {\n        type: 'Comment',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substring(start + 2, end)\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Comment, '/*' + node.value + '*/');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst names = require('../../utils/names.cjs');\nconst types = require('../../tokenizer/types.cjs');\n\nconst EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\nconst NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)\nconst DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n\nfunction consumeValueRaw(startToken) {\n    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);\n}\n\nfunction consumeCustomPropertyRaw(startToken) {\n    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);\n}\n\nfunction consumeValue() {\n    const startValueToken = this.tokenIndex;\n    const value = this.Value();\n\n    if (value.type !== 'Raw' &&\n        this.eof === false &&\n        this.tokenType !== types.Semicolon &&\n        this.isDelim(EXCLAMATIONMARK) === false &&\n        this.isBalanceEdge(startValueToken) === false) {\n        this.error();\n    }\n\n    return value;\n}\n\nconst name = 'Declaration';\nconst walkContext = 'declaration';\nconst structure = {\n    important: [Boolean, String],\n    property: String,\n    value: ['Value', 'Raw']\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n    const startToken = this.tokenIndex;\n    const property = readProperty.call(this);\n    const customProperty = names.isCustomProperty(property);\n    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;\n    const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;\n    let important = false;\n    let value;\n\n    this.skipSC();\n    this.eat(types.Colon);\n\n    const valueStart = this.tokenIndex;\n\n    if (!customProperty) {\n        this.skipSC();\n    }\n\n    if (parseValue) {\n        value = this.parseWithFallback(consumeValue, consumeRaw);\n    } else {\n        value = consumeRaw.call(this, this.tokenIndex);\n    }\n\n    if (customProperty && value.type === 'Value' && value.children.isEmpty) {\n        for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {\n            if (this.lookupType(offset) === types.WhiteSpace) {\n                value.children.appendData({\n                    type: 'WhiteSpace',\n                    loc: null,\n                    value: ' '\n                });\n                break;\n            }\n        }\n    }\n\n    if (this.isDelim(EXCLAMATIONMARK)) {\n        important = getImportant.call(this);\n        this.skipSC();\n    }\n\n    // Do not include semicolon to range per spec\n    // https://drafts.csswg.org/css-syntax/#declaration-diagram\n\n    if (this.eof === false &&\n        this.tokenType !== types.Semicolon &&\n        this.isBalanceEdge(startToken) === false) {\n        this.error();\n    }\n\n    return {\n        type: 'Declaration',\n        loc: this.getLocation(start, this.tokenStart),\n        important,\n        property,\n        value\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Ident, node.property);\n    this.token(types.Colon, ':');\n    this.node(node.value);\n\n    if (node.important) {\n        this.token(types.Delim, '!');\n        this.token(types.Ident, node.important === true ? 'important' : node.important);\n    }\n}\n\nfunction readProperty() {\n    const start = this.tokenStart;\n\n    // hacks\n    if (this.tokenType === types.Delim) {\n        switch (this.charCodeAt(this.tokenStart)) {\n            case ASTERISK:\n            case DOLLARSIGN:\n            case PLUSSIGN:\n            case NUMBERSIGN:\n            case AMPERSAND:\n                this.next();\n                break;\n\n            // TODO: not sure we should support this hack\n            case SOLIDUS:\n                this.next();\n                if (this.isDelim(SOLIDUS)) {\n                    this.next();\n                }\n                break;\n        }\n    }\n\n    if (this.tokenType === types.Hash) {\n        this.eat(types.Hash);\n    } else {\n        this.eat(types.Ident);\n    }\n\n    return this.substrToCursor(start);\n}\n\n// ! ws* important\nfunction getImportant() {\n    this.eat(types.Delim);\n    this.skipSC();\n\n    const important = this.consume(types.Ident);\n\n    // store original value in case it differ from `important`\n    // for better original source restoring and hacks like `!ie` support\n    return important === 'important' ? true : important;\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.walkContext = walkContext;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nfunction consumeRaw(startToken) {\n    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);\n}\n\nconst name = 'DeclarationList';\nconst structure = {\n    children: [[\n        'Declaration',\n        'Atrule',\n        'Rule'\n    ]]\n};\n\nfunction parse() {\n    const children = this.createList();\n\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case types.WhiteSpace:\n            case types.Comment:\n            case types.Semicolon:\n                this.next();\n                break;\n\n            case types.AtKeyword:\n                children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw));\n                break;\n\n            default:\n                if (this.isDelim(AMPERSAND))  {\n                    children.push(this.parseWithFallback(this.Rule, consumeRaw));\n                } else {\n                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));\n                }\n        }\n    }\n\n    return {\n        type: 'DeclarationList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.children(node, prev => {\n        if (prev.type === 'Declaration') {\n            this.token(types.Semicolon, ';');\n        }\n    });\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'Dimension';\nconst structure = {\n    value: String,\n    unit: String\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n    const value = this.consumeNumber(types.Dimension);\n\n    return {\n        type: 'Dimension',\n        loc: this.getLocation(start, this.tokenStart),\n        value,\n        unit: this.substring(start + value.length, this.tokenStart)\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Dimension, node.value + node.unit);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'Function';\nconst walkContext = 'function';\nconst structure = {\n    name: String,\n    children: [[]]\n};\n\n// <function-token> <sequence> )\nfunction parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    const name = this.consumeFunctionName();\n    const nameLowerCase = name.toLowerCase();\n    let children;\n\n    children = recognizer.hasOwnProperty(nameLowerCase)\n        ? recognizer[nameLowerCase].call(this, recognizer)\n        : readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(types.RightParenthesis);\n    }\n\n    return {\n        type: 'Function',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Function, node.name + '(');\n    this.children(node);\n    this.token(types.RightParenthesis, ')');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.walkContext = walkContext;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\n// '#' ident\nconst xxx = 'XXX';\nconst name = 'Hash';\nconst structure = {\n    value: String\n};\nfunction parse() {\n    const start = this.tokenStart;\n\n    this.eat(types.Hash);\n\n    return {\n        type: 'Hash',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start + 1)\n    };\n}\nfunction generate(node) {\n    this.token(types.Hash, '#' + node.value);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.xxx = xxx;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'Identifier';\nconst structure = {\n    name: String\n};\n\nfunction parse() {\n    return {\n        type: 'Identifier',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        name: this.consume(types.Ident)\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Ident, node.name);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'IdSelector';\nconst structure = {\n    name: String\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n\n    // TODO: check value is an ident\n    this.eat(types.Hash);\n\n    return {\n        type: 'IdSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start + 1)\n    };\n}\n\nfunction generate(node) {\n    // Using Delim instead of Hash is a hack to avoid for a whitespace between ident and id-selector\n    // in safe mode (e.g. \"a#id\"), because IE11 doesn't allow a sequence <ident-token> <hash-token>\n    // without a whitespace in values (e.g. \"1px solid#000\")\n    this.token(types.Delim, '#' + node.name);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'MediaFeature';\nconst structure = {\n    name: String,\n    value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n    let name;\n    let value = null;\n\n    this.eat(types.LeftParenthesis);\n    this.skipSC();\n\n    name = this.consume(types.Ident);\n    this.skipSC();\n\n    if (this.tokenType !== types.RightParenthesis) {\n        this.eat(types.Colon);\n        this.skipSC();\n\n        switch (this.tokenType) {\n            case types.Number:\n                if (this.lookupNonWSType(1) === types.Delim) {\n                    value = this.Ratio();\n                } else {\n                    value = this.Number();\n                }\n\n                break;\n\n            case types.Dimension:\n                value = this.Dimension();\n                break;\n\n            case types.Ident:\n                value = this.Identifier();\n                break;\n\n            default:\n                this.error('Number, dimension, ratio or identifier is expected');\n        }\n\n        this.skipSC();\n    }\n\n    this.eat(types.RightParenthesis);\n\n    return {\n        type: 'MediaFeature',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        value\n    };\n}\n\nfunction generate(node) {\n    this.token(types.LeftParenthesis, '(');\n    this.token(types.Ident, node.name);\n\n    if (node.value !== null) {\n        this.token(types.Colon, ':');\n        this.node(node.value);\n    }\n\n    this.token(types.RightParenthesis, ')');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'MediaQuery';\nconst structure = {\n    children: [[\n        'Identifier',\n        'MediaFeature',\n        'WhiteSpace'\n    ]]\n};\n\nfunction parse() {\n    const children = this.createList();\n    let child = null;\n\n    this.skipSC();\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case types.Comment:\n            case types.WhiteSpace:\n                this.next();\n                continue;\n\n            case types.Ident:\n                child = this.Identifier();\n                break;\n\n            case types.LeftParenthesis:\n                child = this.MediaFeature();\n                break;\n\n            default:\n                break scan;\n        }\n\n        children.push(child);\n    }\n\n    if (child === null) {\n        this.error('Identifier or parenthesis is expected');\n    }\n\n    return {\n        type: 'MediaQuery',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.children(node);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'MediaQueryList';\nconst structure = {\n    children: [[\n        'MediaQuery'\n    ]]\n};\n\nfunction parse() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    while (!this.eof) {\n        children.push(this.MediaQuery());\n\n        if (this.tokenType !== types.Comma) {\n            break;\n        }\n\n        this.next();\n    }\n\n    return {\n        type: 'MediaQueryList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.children(node, () => this.token(types.Comma, ','));\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nconst name = 'NestingSelector';\nconst structure = {\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n\n    this.eatDelim(AMPERSAND);\n\n    return {\n        type: 'NestingSelector',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nfunction generate() {\n    this.token(types.Delim, '&');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'Nth';\nconst structure = {\n    nth: ['AnPlusB', 'Identifier'],\n    selector: ['SelectorList', null]\n};\n\nfunction parse() {\n    this.skipSC();\n\n    const start = this.tokenStart;\n    let end = start;\n    let selector = null;\n    let nth;\n\n    if (this.lookupValue(0, 'odd') || this.lookupValue(0, 'even')) {\n        nth = this.Identifier();\n    } else {\n        nth = this.AnPlusB();\n    }\n\n    end = this.tokenStart;\n    this.skipSC();\n\n    if (this.lookupValue(0, 'of')) {\n        this.next();\n\n        selector = this.SelectorList();\n        end = this.tokenStart;\n    }\n\n    return {\n        type: 'Nth',\n        loc: this.getLocation(start, end),\n        nth,\n        selector\n    };\n}\n\nfunction generate(node) {\n    this.node(node.nth);\n    if (node.selector !== null) {\n        this.token(types.Ident, 'of');\n        this.node(node.selector);\n    }\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'Number';\nconst structure = {\n    value: String\n};\n\nfunction parse() {\n    return {\n        type: 'Number',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: this.consume(types.Number)\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Number, node.value);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\n// '/' | '*' | ',' | ':' | '+' | '-'\nconst name = 'Operator';\nconst structure = {\n    value: String\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n\n    this.next();\n\n    return {\n        type: 'Operator',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start)\n    };\n}\n\nfunction generate(node) {\n    this.tokenize(node.value);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'Parentheses';\nconst structure = {\n    children: [[]]\n};\n\nfunction parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    let children = null;\n\n    this.eat(types.LeftParenthesis);\n\n    children = readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(types.RightParenthesis);\n    }\n\n    return {\n        type: 'Parentheses',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.token(types.LeftParenthesis, '(');\n    this.children(node);\n    this.token(types.RightParenthesis, ')');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'Percentage';\nconst structure = {\n    value: String\n};\n\nfunction parse() {\n    return {\n        type: 'Percentage',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: this.consumeNumber(types.Percentage)\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Percentage, node.value + '%');\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'PseudoClassSelector';\nconst walkContext = 'function';\nconst structure = {\n    name: String,\n    children: [['Raw'], null]\n};\n\n// : [ <ident> | <function-token> <any-value>? ) ]\nfunction parse() {\n    const start = this.tokenStart;\n    let children = null;\n    let name;\n    let nameLowerCase;\n\n    this.eat(types.Colon);\n\n    if (this.tokenType === types.Function) {\n        name = this.consumeFunctionName();\n        nameLowerCase = name.toLowerCase();\n\n        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {\n            this.skipSC();\n            children = this.pseudo[nameLowerCase].call(this);\n            this.skipSC();\n        } else {\n            children = this.createList();\n            children.push(\n                this.Raw(this.tokenIndex, null, false)\n            );\n        }\n\n        this.eat(types.RightParenthesis);\n    } else {\n        name = this.consume(types.Ident);\n    }\n\n    return {\n        type: 'PseudoClassSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Colon, ':');\n\n    if (node.children === null) {\n        this.token(types.Ident, node.name);\n    } else {\n        this.token(types.Function, node.name + '(');\n        this.children(node);\n        this.token(types.RightParenthesis, ')');\n    }\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.walkContext = walkContext;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'PseudoElementSelector';\nconst walkContext = 'function';\nconst structure = {\n    name: String,\n    children: [['Raw'], null]\n};\n\n// :: [ <ident> | <function-token> <any-value>? ) ]\nfunction parse() {\n    const start = this.tokenStart;\n    let children = null;\n    let name;\n    let nameLowerCase;\n\n    this.eat(types.Colon);\n    this.eat(types.Colon);\n\n    if (this.tokenType === types.Function) {\n        name = this.consumeFunctionName();\n        nameLowerCase = name.toLowerCase();\n\n        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {\n            this.skipSC();\n            children = this.pseudo[nameLowerCase].call(this);\n            this.skipSC();\n        } else {\n            children = this.createList();\n            children.push(\n                this.Raw(this.tokenIndex, null, false)\n            );\n        }\n\n        this.eat(types.RightParenthesis);\n    } else {\n        name = this.consume(types.Ident);\n    }\n\n    return {\n        type: 'PseudoElementSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Colon, ':');\n    this.token(types.Colon, ':');\n\n    if (node.children === null) {\n        this.token(types.Ident, node.name);\n    } else {\n        this.token(types.Function, node.name + '(');\n        this.children(node);\n        this.token(types.RightParenthesis, ')');\n    }\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.walkContext = walkContext;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\nconst charCodeDefinitions = require('../../tokenizer/char-code-definitions.cjs');\n\nconst SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)\nconst FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\n// Terms of <ratio> should be a positive numbers (not zero or negative)\n// (see https://drafts.csswg.org/mediaqueries-3/#values)\n// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term\n// and this is using by various sites. Therefore we relax checking on parse\n// to test a term is unsigned number without an exponent part.\n// Additional checking may be applied on lexer validation.\nfunction consumeNumber() {\n    this.skipSC();\n\n    const value = this.consume(types.Number);\n\n    for (let i = 0; i < value.length; i++) {\n        const code = value.charCodeAt(i);\n        if (!charCodeDefinitions.isDigit(code) && code !== FULLSTOP) {\n            this.error('Unsigned number is expected', this.tokenStart - value.length + i);\n        }\n    }\n\n    if (Number(value) === 0) {\n        this.error('Zero number is not allowed', this.tokenStart - value.length);\n    }\n\n    return value;\n}\n\nconst name = 'Ratio';\nconst structure = {\n    left: String,\n    right: String\n};\n\n// <positive-integer> S* '/' S* <positive-integer>\nfunction parse() {\n    const start = this.tokenStart;\n    const left = consumeNumber.call(this);\n    let right;\n\n    this.skipSC();\n    this.eatDelim(SOLIDUS);\n    right = consumeNumber.call(this);\n\n    return {\n        type: 'Ratio',\n        loc: this.getLocation(start, this.tokenStart),\n        left,\n        right\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Number, node.left);\n    this.token(types.Delim, '/');\n    this.token(types.Number, node.right);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nfunction getOffsetExcludeWS() {\n    if (this.tokenIndex > 0) {\n        if (this.lookupType(-1) === types.WhiteSpace) {\n            return this.tokenIndex > 1\n                ? this.getTokenStart(this.tokenIndex - 1)\n                : this.firstCharOffset;\n        }\n    }\n\n    return this.tokenStart;\n}\n\nconst name = 'Raw';\nconst structure = {\n    value: String\n};\n\nfunction parse(startToken, consumeUntil, excludeWhiteSpace) {\n    const startOffset = this.getTokenStart(startToken);\n    let endOffset;\n\n    this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);\n\n    if (excludeWhiteSpace && this.tokenStart > startOffset) {\n        endOffset = getOffsetExcludeWS.call(this);\n    } else {\n        endOffset = this.tokenStart;\n    }\n\n    return {\n        type: 'Raw',\n        loc: this.getLocation(startOffset, endOffset),\n        value: this.substring(startOffset, endOffset)\n    };\n}\n\nfunction generate(node) {\n    this.tokenize(node.value);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nfunction consumeRaw(startToken) {\n    return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);\n}\n\nfunction consumePrelude() {\n    const prelude = this.SelectorList();\n\n    if (prelude.type !== 'Raw' &&\n        this.eof === false &&\n        this.tokenType !== types.LeftCurlyBracket) {\n        this.error();\n    }\n\n    return prelude;\n}\n\nconst name = 'Rule';\nconst walkContext = 'rule';\nconst structure = {\n    prelude: ['SelectorList', 'Raw'],\n    block: ['Block']\n};\n\nfunction parse() {\n    const startToken = this.tokenIndex;\n    const startOffset = this.tokenStart;\n    let prelude;\n    let block;\n\n    if (this.parseRulePrelude) {\n        prelude = this.parseWithFallback(consumePrelude, consumeRaw);\n    } else {\n        prelude = consumeRaw.call(this, startToken);\n    }\n\n    block = this.Block(true);\n\n    return {\n        type: 'Rule',\n        loc: this.getLocation(startOffset, this.tokenStart),\n        prelude,\n        block\n    };\n}\nfunction generate(node) {\n    this.node(node.prelude);\n    this.node(node.block);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.walkContext = walkContext;\n","'use strict';\n\nconst name = 'Selector';\nconst structure = {\n    children: [[\n        'TypeSelector',\n        'IdSelector',\n        'ClassSelector',\n        'AttributeSelector',\n        'PseudoClassSelector',\n        'PseudoElementSelector',\n        'Combinator',\n        'WhiteSpace'\n    ]]\n};\n\nfunction parse() {\n    const children = this.readSequence(this.scope.Selector);\n\n    // nothing were consumed\n    if (this.getFirstListNode(children) === null) {\n        this.error('Selector is expected');\n    }\n\n    return {\n        type: 'Selector',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.children(node);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'SelectorList';\nconst walkContext = 'selector';\nconst structure = {\n    children: [[\n        'Selector',\n        'Raw'\n    ]]\n};\n\nfunction parse() {\n    const children = this.createList();\n\n    while (!this.eof) {\n        children.push(this.Selector());\n\n        if (this.tokenType === types.Comma) {\n            this.next();\n            continue;\n        }\n\n        break;\n    }\n\n    return {\n        type: 'SelectorList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.children(node, () => this.token(types.Comma, ','));\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.walkContext = walkContext;\n","'use strict';\n\nconst charCodeDefinitions = require('../tokenizer/char-code-definitions.cjs');\nconst utils = require('../tokenizer/utils.cjs');\n\nconst REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\nconst QUOTATION_MARK = 0x0022;  // \"\nconst APOSTROPHE = 0x0027;      // '\n\nfunction decode(str) {\n    const len = str.length;\n    const firstChar = str.charCodeAt(0);\n    const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;\n    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;\n    let decoded = '';\n\n    for (let i = start; i <= end; i++) {\n        let code = str.charCodeAt(i);\n\n        if (code === REVERSE_SOLIDUS) {\n            // special case at the ending\n            if (i === end) {\n                // if the next input code point is EOF, do nothing\n                // otherwise include last quote as escaped\n                if (i !== len - 1) {\n                    decoded = str.substr(i + 1);\n                }\n                break;\n            }\n\n            code = str.charCodeAt(++i);\n\n            // consume escaped\n            if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {\n                const escapeStart = i - 1;\n                const escapeEnd = utils.consumeEscaped(str, escapeStart);\n\n                i = escapeEnd - 1;\n                decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n            } else {\n                // \\r\\n\n                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n                    i++;\n                }\n            }\n        } else {\n            decoded += str[i];\n        }\n    }\n\n    return decoded;\n}\n\n// https://drafts.csswg.org/cssom/#serialize-a-string\n// § 2.1. Common Serializing Idioms\nfunction encode(str, apostrophe) {\n    const quote = apostrophe ? '\\'' : '\"';\n    const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;\n    let encoded = '';\n    let wsBeforeHexIsNeeded = false;\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n        if (code === 0x0000) {\n            encoded += '\\uFFFD';\n            continue;\n        }\n\n        // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F,\n        // the character escaped as code point.\n        // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n        if (code <= 0x001f || code === 0x007F) {\n            encoded += '\\\\' + code.toString(16);\n            wsBeforeHexIsNeeded = true;\n            continue;\n        }\n\n        // If the character is '\"' (U+0022) or \"\\\" (U+005C), the escaped character.\n        if (code === quoteCode || code === REVERSE_SOLIDUS) {\n            encoded += '\\\\' + str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        } else {\n            if (wsBeforeHexIsNeeded && (charCodeDefinitions.isHexDigit(code) || charCodeDefinitions.isWhiteSpace(code))) {\n                encoded += ' ';\n            }\n\n            // Otherwise, the character itself.\n            encoded += str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        }\n    }\n\n    return quote + encoded + quote;\n}\n\nexports.decode = decode;\nexports.encode = encode;\n","'use strict';\n\nconst string = require('../../utils/string.cjs');\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'String';\nconst structure = {\n    value: String\n};\n\nfunction parse() {\n    return {\n        type: 'String',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: string.decode(this.consume(types.String))\n    };\n}\n\nfunction generate(node) {\n    this.token(types.String, string.encode(node.value));\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\n\nfunction consumeRaw(startToken) {\n    return this.Raw(startToken, null, false);\n}\n\nconst name = 'StyleSheet';\nconst walkContext = 'stylesheet';\nconst structure = {\n    children: [[\n        'Comment',\n        'CDO',\n        'CDC',\n        'Atrule',\n        'Rule',\n        'Raw'\n    ]]\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n    const children = this.createList();\n    let child;\n\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case types.WhiteSpace:\n                this.next();\n                continue;\n\n            case types.Comment:\n                // ignore comments except exclamation comments (i.e. /*! .. */) on top level\n                if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {\n                    this.next();\n                    continue;\n                }\n\n                child = this.Comment();\n                break;\n\n            case types.CDO: // <!--\n                child = this.CDO();\n                break;\n\n            case types.CDC: // -->\n                child = this.CDC();\n                break;\n\n            // CSS Syntax Module Level 3\n            // §2.2 Error handling\n            // At the \"top level\" of a stylesheet, an <at-keyword-token> starts an at-rule.\n            case types.AtKeyword:\n                child = this.parseWithFallback(this.Atrule, consumeRaw);\n                break;\n\n            // Anything else starts a qualified rule ...\n            default:\n                child = this.parseWithFallback(this.Rule, consumeRaw);\n        }\n\n        children.push(child);\n    }\n\n    return {\n        type: 'StyleSheet',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.children(node);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\nexports.walkContext = walkContext;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst ASTERISK = 0x002A;     // U+002A ASTERISK (*)\nconst VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)\n\nfunction eatIdentifierOrAsterisk() {\n    if (this.tokenType !== types.Ident &&\n        this.isDelim(ASTERISK) === false) {\n        this.error('Identifier or asterisk is expected');\n    }\n\n    this.next();\n}\n\nconst name = 'TypeSelector';\nconst structure = {\n    name: String\n};\n\n// ident\n// ident|ident\n// ident|*\n// *\n// *|ident\n// *|*\n// |ident\n// |*\nfunction parse() {\n    const start = this.tokenStart;\n\n    if (this.isDelim(VERTICALLINE)) {\n        this.next();\n        eatIdentifierOrAsterisk.call(this);\n    } else {\n        eatIdentifierOrAsterisk.call(this);\n\n        if (this.isDelim(VERTICALLINE)) {\n            this.next();\n            eatIdentifierOrAsterisk.call(this);\n        }\n    }\n\n    return {\n        type: 'TypeSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start)\n    };\n}\n\nfunction generate(node) {\n    this.tokenize(node.name);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\nconst charCodeDefinitions = require('../../tokenizer/char-code-definitions.cjs');\n\nconst PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)\nconst QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\n\nfunction eatHexSequence(offset, allowDash) {\n    let len = 0;\n\n    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {\n        const code = this.charCodeAt(pos);\n\n        if (code === HYPHENMINUS && allowDash && len !== 0) {\n            eatHexSequence.call(this, offset + len + 1, false);\n            return -1;\n        }\n\n        if (!charCodeDefinitions.isHexDigit(code)) {\n            this.error(\n                allowDash && len !== 0\n                    ? 'Hyphen minus' + (len < 6 ? ' or hex digit' : '') + ' is expected'\n                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),\n                pos\n            );\n        }\n\n        if (++len > 6) {\n            this.error('Too many hex digits', pos);\n        }    }\n\n    this.next();\n    return len;\n}\n\nfunction eatQuestionMarkSequence(max) {\n    let count = 0;\n\n    while (this.isDelim(QUESTIONMARK)) {\n        if (++count > max) {\n            this.error('Too many question marks');\n        }\n\n        this.next();\n    }\n}\n\nfunction startsWith(code) {\n    if (this.charCodeAt(this.tokenStart) !== code) {\n        this.error((code === PLUSSIGN ? 'Plus sign' : 'Hyphen minus') + ' is expected');\n    }\n}\n\n// https://drafts.csswg.org/css-syntax/#urange\n// Informally, the <urange> production has three forms:\n// U+0001\n//      Defines a range consisting of a single code point, in this case the code point \"1\".\n// U+0001-00ff\n//      Defines a range of codepoints between the first and the second value, in this case\n//      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n// U+00??\n//      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n//      in this case defining the same as the value U+0000-00ff.\n// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n//\n// <urange> =\n//   u '+' <ident-token> '?'* |\n//   u <dimension-token> '?'* |\n//   u <number-token> '?'* |\n//   u <number-token> <dimension-token> |\n//   u <number-token> <number-token> |\n//   u '+' '?'+\nfunction scanUnicodeRange() {\n    let hexLength = 0;\n\n    switch (this.tokenType) {\n        case types.Number:\n            // u <number-token> '?'*\n            // u <number-token> <dimension-token>\n            // u <number-token> <number-token>\n            hexLength = eatHexSequence.call(this, 1, true);\n\n            if (this.isDelim(QUESTIONMARK)) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n                break;\n            }\n\n            if (this.tokenType === types.Dimension ||\n                this.tokenType === types.Number) {\n                startsWith.call(this, HYPHENMINUS);\n                eatHexSequence.call(this, 1, false);\n                break;\n            }\n\n            break;\n\n        case types.Dimension:\n            // u <dimension-token> '?'*\n            hexLength = eatHexSequence.call(this, 1, true);\n\n            if (hexLength > 0) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n            }\n\n            break;\n\n        default:\n            // u '+' <ident-token> '?'*\n            // u '+' '?'+\n            this.eatDelim(PLUSSIGN);\n\n            if (this.tokenType === types.Ident) {\n                hexLength = eatHexSequence.call(this, 0, true);\n                if (hexLength > 0) {\n                    eatQuestionMarkSequence.call(this, 6 - hexLength);\n                }\n                break;\n            }\n\n            if (this.isDelim(QUESTIONMARK)) {\n                this.next();\n                eatQuestionMarkSequence.call(this, 5);\n                break;\n            }\n\n            this.error('Hex digit or question mark is expected');\n    }\n}\n\nconst name = 'UnicodeRange';\nconst structure = {\n    value: String\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n\n    // U or u\n    this.eatIdent('u');\n    scanUnicodeRange.call(this);\n\n    return {\n        type: 'UnicodeRange',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start)\n    };\n}\n\nfunction generate(node) {\n    this.tokenize(node.value);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst charCodeDefinitions = require('../tokenizer/char-code-definitions.cjs');\nconst utils = require('../tokenizer/utils.cjs');\n\nconst SPACE = 0x0020;            // U+0020 SPACE\nconst REVERSE_SOLIDUS = 0x005c;  // U+005C REVERSE SOLIDUS (\\)\nconst QUOTATION_MARK = 0x0022;   // \"\nconst APOSTROPHE = 0x0027;       // '\nconst LEFTPARENTHESIS = 0x0028;  // U+0028 LEFT PARENTHESIS (()\nconst RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())\n\nfunction decode(str) {\n    const len = str.length;\n    let start = 4; // length of \"url(\"\n    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;\n    let decoded = '';\n\n    while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(start))) {\n        start++;\n    }\n\n    while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(end))) {\n        end--;\n    }\n\n    for (let i = start; i <= end; i++) {\n        let code = str.charCodeAt(i);\n\n        if (code === REVERSE_SOLIDUS) {\n            // special case at the ending\n            if (i === end) {\n                // if the next input code point is EOF, do nothing\n                // otherwise include last left parenthesis as escaped\n                if (i !== len - 1) {\n                    decoded = str.substr(i + 1);\n                }\n                break;\n            }\n\n            code = str.charCodeAt(++i);\n\n            // consume escaped\n            if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {\n                const escapeStart = i - 1;\n                const escapeEnd = utils.consumeEscaped(str, escapeStart);\n\n                i = escapeEnd - 1;\n                decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n            } else {\n                // \\r\\n\n                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n                    i++;\n                }\n            }\n        } else {\n            decoded += str[i];\n        }\n    }\n\n    return decoded;\n}\n\nfunction encode(str) {\n    let encoded = '';\n    let wsBeforeHexIsNeeded = false;\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n        if (code === 0x0000) {\n            encoded += '\\uFFFD';\n            continue;\n        }\n\n        // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F,\n        // the character escaped as code point.\n        // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n        if (code <= 0x001f || code === 0x007F) {\n            encoded += '\\\\' + code.toString(16);\n            wsBeforeHexIsNeeded = true;\n            continue;\n        }\n\n        if (code === SPACE ||\n            code === REVERSE_SOLIDUS ||\n            code === QUOTATION_MARK ||\n            code === APOSTROPHE ||\n            code === LEFTPARENTHESIS ||\n            code === RIGHTPARENTHESIS) {\n            encoded += '\\\\' + str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        } else {\n            if (wsBeforeHexIsNeeded && charCodeDefinitions.isHexDigit(code)) {\n                encoded += ' ';\n            }\n\n            encoded += str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        }\n    }\n\n    return 'url(' + encoded + ')';\n}\n\nexports.decode = decode;\nexports.encode = encode;\n","'use strict';\n\nconst url = require('../../utils/url.cjs');\nconst string = require('../../utils/string.cjs');\nconst types = require('../../tokenizer/types.cjs');\n\nconst name = 'Url';\nconst structure = {\n    value: String\n};\n\n// <url-token> | <function-token> <string> )\nfunction parse() {\n    const start = this.tokenStart;\n    let value;\n\n    switch (this.tokenType) {\n        case types.Url:\n            value = url.decode(this.consume(types.Url));\n            break;\n\n        case types.Function:\n            if (!this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')) {\n                this.error('Function name must be `url`');\n            }\n\n            this.eat(types.Function);\n            this.skipSC();\n            value = string.decode(this.consume(types.String));\n            this.skipSC();\n            if (!this.eof) {\n                this.eat(types.RightParenthesis);\n            }\n            break;\n\n        default:\n            this.error('Url or Function is expected');\n    }\n\n    return {\n        type: 'Url',\n        loc: this.getLocation(start, this.tokenStart),\n        value\n    };\n}\n\nfunction generate(node) {\n    this.token(types.Url, url.encode(node.value));\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst name = 'Value';\nconst structure = {\n    children: [[]]\n};\n\nfunction parse() {\n    const start = this.tokenStart;\n    const children = this.readSequence(this.scope.Value);\n\n    return {\n        type: 'Value',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nfunction generate(node) {\n    this.children(node);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst SPACE = Object.freeze({\n    type: 'WhiteSpace',\n    loc: null,\n    value: ' '\n});\n\nconst name = 'WhiteSpace';\nconst structure = {\n    value: String\n};\n\nfunction parse() {\n    this.eat(types.WhiteSpace);\n    return SPACE;\n\n    // return {\n    //     type: 'WhiteSpace',\n    //     loc: this.getLocation(this.tokenStart, this.tokenEnd),\n    //     value: this.consume(WHITESPACE)\n    // };\n}\n\nfunction generate(node) {\n    this.token(types.WhiteSpace, node.value);\n}\n\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;\n","'use strict';\n\nconst AnPlusB = require('./AnPlusB.cjs');\nconst Atrule = require('./Atrule.cjs');\nconst AtrulePrelude = require('./AtrulePrelude.cjs');\nconst AttributeSelector = require('./AttributeSelector.cjs');\nconst Block = require('./Block.cjs');\nconst Brackets = require('./Brackets.cjs');\nconst CDC = require('./CDC.cjs');\nconst CDO = require('./CDO.cjs');\nconst ClassSelector = require('./ClassSelector.cjs');\nconst Combinator = require('./Combinator.cjs');\nconst Comment = require('./Comment.cjs');\nconst Declaration = require('./Declaration.cjs');\nconst DeclarationList = require('./DeclarationList.cjs');\nconst Dimension = require('./Dimension.cjs');\nconst Function = require('./Function.cjs');\nconst Hash = require('./Hash.cjs');\nconst Identifier = require('./Identifier.cjs');\nconst IdSelector = require('./IdSelector.cjs');\nconst MediaFeature = require('./MediaFeature.cjs');\nconst MediaQuery = require('./MediaQuery.cjs');\nconst MediaQueryList = require('./MediaQueryList.cjs');\nconst NestingSelector = require('./NestingSelector.cjs');\nconst Nth = require('./Nth.cjs');\nconst Number$1 = require('./Number.cjs');\nconst Operator = require('./Operator.cjs');\nconst Parentheses = require('./Parentheses.cjs');\nconst Percentage = require('./Percentage.cjs');\nconst PseudoClassSelector = require('./PseudoClassSelector.cjs');\nconst PseudoElementSelector = require('./PseudoElementSelector.cjs');\nconst Ratio = require('./Ratio.cjs');\nconst Raw = require('./Raw.cjs');\nconst Rule = require('./Rule.cjs');\nconst Selector = require('./Selector.cjs');\nconst SelectorList = require('./SelectorList.cjs');\nconst String$1 = require('./String.cjs');\nconst StyleSheet = require('./StyleSheet.cjs');\nconst TypeSelector = require('./TypeSelector.cjs');\nconst UnicodeRange = require('./UnicodeRange.cjs');\nconst Url = require('./Url.cjs');\nconst Value = require('./Value.cjs');\nconst WhiteSpace = require('./WhiteSpace.cjs');\n\n\n\nexports.AnPlusB = AnPlusB;\nexports.Atrule = Atrule;\nexports.AtrulePrelude = AtrulePrelude;\nexports.AttributeSelector = AttributeSelector;\nexports.Block = Block;\nexports.Brackets = Brackets;\nexports.CDC = CDC;\nexports.CDO = CDO;\nexports.ClassSelector = ClassSelector;\nexports.Combinator = Combinator;\nexports.Comment = Comment;\nexports.Declaration = Declaration;\nexports.DeclarationList = DeclarationList;\nexports.Dimension = Dimension;\nexports.Function = Function;\nexports.Hash = Hash;\nexports.Identifier = Identifier;\nexports.IdSelector = IdSelector;\nexports.MediaFeature = MediaFeature;\nexports.MediaQuery = MediaQuery;\nexports.MediaQueryList = MediaQueryList;\nexports.NestingSelector = NestingSelector;\nexports.Nth = Nth;\nexports.Number = Number$1;\nexports.Operator = Operator;\nexports.Parentheses = Parentheses;\nexports.Percentage = Percentage;\nexports.PseudoClassSelector = PseudoClassSelector;\nexports.PseudoElementSelector = PseudoElementSelector;\nexports.Ratio = Ratio;\nexports.Raw = Raw;\nexports.Rule = Rule;\nexports.Selector = Selector;\nexports.SelectorList = SelectorList;\nexports.String = String$1;\nexports.StyleSheet = StyleSheet;\nexports.TypeSelector = TypeSelector;\nexports.UnicodeRange = UnicodeRange;\nexports.Url = Url;\nexports.Value = Value;\nexports.WhiteSpace = WhiteSpace;\n","'use strict';\n\nconst data = require('../../data.cjs');\nconst index = require('../node/index.cjs');\n\nconst lexerConfig = {\n    generic: true,\n    ...data,\n    node: index\n};\n\nmodule.exports = lexerConfig;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst NUMBERSIGN = 0x0023;  // U+0023 NUMBER SIGN (#)\nconst ASTERISK = 0x002A;    // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst SOLIDUS = 0x002F;     // U+002F SOLIDUS (/)\nconst U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)\n\nfunction defaultRecognizer(context) {\n    switch (this.tokenType) {\n        case types.Hash:\n            return this.Hash();\n\n        case types.Comma:\n            return this.Operator();\n\n        case types.LeftParenthesis:\n            return this.Parentheses(this.readSequence, context.recognizer);\n\n        case types.LeftSquareBracket:\n            return this.Brackets(this.readSequence, context.recognizer);\n\n        case types.String:\n            return this.String();\n\n        case types.Dimension:\n            return this.Dimension();\n\n        case types.Percentage:\n            return this.Percentage();\n\n        case types.Number:\n            return this.Number();\n\n        case types.Function:\n            return this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')\n                ? this.Url()\n                : this.Function(this.readSequence, context.recognizer);\n\n        case types.Url:\n            return this.Url();\n\n        case types.Ident:\n            // check for unicode range, it should start with u+ or U+\n            if (this.cmpChar(this.tokenStart, U) &&\n                this.cmpChar(this.tokenStart + 1, PLUSSIGN)) {\n                return this.UnicodeRange();\n            } else {\n                return this.Identifier();\n            }\n\n        case types.Delim: {\n            const code = this.charCodeAt(this.tokenStart);\n\n            if (code === SOLIDUS ||\n                code === ASTERISK ||\n                code === PLUSSIGN ||\n                code === HYPHENMINUS) {\n                return this.Operator(); // TODO: replace with Delim\n            }\n\n            // TODO: produce a node with Delim node type\n\n            if (code === NUMBERSIGN) {\n                this.error('Hex or identifier is expected', this.tokenStart + 1);\n            }\n\n            break;\n        }\n    }\n}\n\nmodule.exports = defaultRecognizer;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst FULLSTOP = 0x002E;        // U+002E FULL STOP (.)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\nconst VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)\nconst TILDE = 0x007E;           // U+007E TILDE (~)\n\nfunction onWhiteSpace(next, children) {\n    if (children.last !== null && children.last.type !== 'Combinator' &&\n        next !== null && next.type !== 'Combinator') {\n        children.push({  // FIXME: this.Combinator() should be used instead\n            type: 'Combinator',\n            loc: null,\n            name: ' '\n        });\n    }\n}\n\nfunction getNode() {\n    switch (this.tokenType) {\n        case types.LeftSquareBracket:\n            return this.AttributeSelector();\n\n        case types.Hash:\n            return this.IdSelector();\n\n        case types.Colon:\n            if (this.lookupType(1) === types.Colon) {\n                return this.PseudoElementSelector();\n            } else {\n                return this.PseudoClassSelector();\n            }\n\n        case types.Ident:\n            return this.TypeSelector();\n\n        case types.Number:\n        case types.Percentage:\n            return this.Percentage();\n\n        case types.Dimension:\n            // throws when .123ident\n            if (this.charCodeAt(this.tokenStart) === FULLSTOP) {\n                this.error('Identifier is expected', this.tokenStart + 1);\n            }\n            break;\n\n        case types.Delim: {\n            const code = this.charCodeAt(this.tokenStart);\n\n            switch (code) {\n                case PLUSSIGN:\n                case GREATERTHANSIGN:\n                case TILDE:\n                case SOLIDUS:  // /deep/\n                    return this.Combinator();\n\n                case FULLSTOP:\n                    return this.ClassSelector();\n\n                case ASTERISK:\n                case VERTICALLINE:\n                    return this.TypeSelector();\n\n                case NUMBERSIGN:\n                    return this.IdSelector();\n\n                case AMPERSAND:\n                    return this.NestingSelector();\n            }\n\n            break;\n        }\n    }\n}\nconst Selector = {\n    onWhiteSpace,\n    getNode\n};\n\nmodule.exports = Selector;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\n// var( <ident> , <value>? )\nfunction varFn() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer\n    children.push(this.Identifier());\n\n    this.skipSC();\n\n    if (this.tokenType === types.Comma) {\n        children.push(this.Operator());\n\n        const startIndex = this.tokenIndex;\n        const value = this.parseCustomProperty\n            ? this.Value(null)\n            : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);\n\n        if (value.type === 'Value' && value.children.isEmpty) {\n            for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {\n                if (this.lookupType(offset) === types.WhiteSpace) {\n                    value.children.appendData({\n                        type: 'WhiteSpace',\n                        loc: null,\n                        value: ' '\n                    });\n                    break;\n                }\n            }\n        }\n\n        children.push(value);\n    }\n\n    return children;\n}\n\nmodule.exports = varFn;\n","'use strict';\n\nconst _default = require('./default.cjs');\nconst expression = require('../function/expression.cjs');\nconst _var = require('../function/var.cjs');\n\nfunction isPlusMinusOperator(node) {\n    return (\n        node !== null &&\n        node.type === 'Operator' &&\n        (node.value[node.value.length - 1] === '-' || node.value[node.value.length - 1] === '+')\n    );\n}\n\nconst value = {\n    getNode: _default,\n    onWhiteSpace(next, children) {\n        if (isPlusMinusOperator(next)) {\n            next.value = ' ' + next.value;\n        }\n        if (isPlusMinusOperator(children.last)) {\n            children.last.value += ' ';\n        }\n    },\n    'expression': expression,\n    'var': _var\n};\n\nmodule.exports = value;\n","'use strict';\n\nconst atrulePrelude = require('./atrulePrelude.cjs');\nconst selector = require('./selector.cjs');\nconst value = require('./value.cjs');\n\n\n\nexports.AtrulePrelude = atrulePrelude;\nexports.Selector = selector;\nexports.Value = value;\n","'use strict';\n\nconst _default = require('./default.cjs');\n\nconst atrulePrelude = {\n    getNode: _default\n};\n\nmodule.exports = atrulePrelude;\n","'use strict';\n\n// legacy IE function\n// expression( <any-value> )\nfunction expressionFn() {\n    return this.createSingleNodeList(\n        this.Raw(this.tokenIndex, null, false)\n    );\n}\n\nmodule.exports = expressionFn;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nconst importAtrule = {\n    parse: {\n        prelude() {\n            const children = this.createList();\n\n            this.skipSC();\n\n            switch (this.tokenType) {\n                case types.String:\n                    children.push(this.String());\n                    break;\n\n                case types.Url:\n                case types.Function:\n                    children.push(this.Url());\n                    break;\n\n                default:\n                    this.error('String or url() is expected');\n            }\n\n            if (this.lookupNonWSType(0) === types.Ident ||\n                this.lookupNonWSType(0) === types.LeftParenthesis) {\n                children.push(this.MediaQueryList());\n            }\n\n            return children;\n        },\n        block: null\n    }\n};\n\nmodule.exports = importAtrule;\n","'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\n\nfunction consumeRaw() {\n    return this.createSingleNodeList(\n        this.Raw(this.tokenIndex, null, false)\n    );\n}\n\nfunction parentheses() {\n    this.skipSC();\n\n    if (this.tokenType === types.Ident &&\n        this.lookupNonWSType(1) === types.Colon) {\n        return this.createSingleNodeList(\n            this.Declaration()\n        );\n    }\n\n    return readSequence.call(this);\n}\n\nfunction readSequence() {\n    const children = this.createList();\n    let child;\n\n    this.skipSC();\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case types.Comment:\n            case types.WhiteSpace:\n                this.next();\n                continue;\n\n            case types.Function:\n                child = this.Function(consumeRaw, this.scope.AtrulePrelude);\n                break;\n\n            case types.Ident:\n                child = this.Identifier();\n                break;\n\n            case types.LeftParenthesis:\n                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);\n                break;\n\n            default:\n                break scan;\n        }\n\n        children.push(child);\n    }\n\n    return children;\n}\n\nconst supports = {\n    parse: {\n        prelude() {\n            const children = readSequence.call(this);\n\n            if (this.getFirstListNode(children) === null) {\n                this.error('Condition is expected');\n            }\n\n            return children;\n        },\n        block(isStyleBlock = false) {\n            return this.Block(isStyleBlock);\n        }\n    }\n};\n\nmodule.exports = supports;\n","'use strict';\n\nconst fontFace = require('./font-face.cjs');\nconst _import = require('./import.cjs');\nconst media = require('./media.cjs');\nconst nest = require('./nest.cjs');\nconst page = require('./page.cjs');\nconst supports = require('./supports.cjs');\n\nconst atrule = {\n    'font-face': fontFace,\n    'import': _import,\n    media,\n    nest,\n    page,\n    supports\n};\n\nmodule.exports = atrule;\n","'use strict';\n\nconst fontFace = {\n    parse: {\n        prelude: null,\n        block() {\n            return this.Block(true);\n        }\n    }\n};\n\nmodule.exports = fontFace;\n","'use strict';\n\nconst media = {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.MediaQueryList()\n            );\n        },\n        block(isStyleBlock = false) {\n            return this.Block(isStyleBlock);\n        }\n    }\n};\n\nmodule.exports = media;\n","'use strict';\n\nconst nest = {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.SelectorList()\n            );\n        },\n        block() {\n            return this.Block(true);\n        }\n    }\n};\n\nmodule.exports = nest;\n","'use strict';\n\nconst page = {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.SelectorList()\n            );\n        },\n        block() {\n            return this.Block(true);\n        }\n    }\n};\n\nmodule.exports = page;\n","'use strict';\n\nconst selectorList = {\n    parse() {\n        return this.createSingleNodeList(\n            this.SelectorList()\n        );\n    }\n};\n\nconst selector = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Selector()\n        );\n    }\n};\n\nconst identList = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Identifier()\n        );\n    }\n};\n\nconst nth = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Nth()\n        );\n    }\n};\n\nconst pseudo = {\n    'dir': identList,\n    'has': selectorList,\n    'lang': identList,\n    'matches': selectorList,\n    'is': selectorList,\n    '-moz-any': selectorList,\n    '-webkit-any': selectorList,\n    'where': selectorList,\n    'not': selectorList,\n    'nth-child': nth,\n    'nth-last-child': nth,\n    'nth-last-of-type': nth,\n    'nth-of-type': nth,\n    'slotted': selector,\n    'host': selector,\n    'host-context': selector\n};\n\nmodule.exports = pseudo;\n","'use strict';\n\nconst AnPlusB = require('./AnPlusB.cjs');\nconst Atrule = require('./Atrule.cjs');\nconst AtrulePrelude = require('./AtrulePrelude.cjs');\nconst AttributeSelector = require('./AttributeSelector.cjs');\nconst Block = require('./Block.cjs');\nconst Brackets = require('./Brackets.cjs');\nconst CDC = require('./CDC.cjs');\nconst CDO = require('./CDO.cjs');\nconst ClassSelector = require('./ClassSelector.cjs');\nconst Combinator = require('./Combinator.cjs');\nconst Comment = require('./Comment.cjs');\nconst Declaration = require('./Declaration.cjs');\nconst DeclarationList = require('./DeclarationList.cjs');\nconst Dimension = require('./Dimension.cjs');\nconst Function = require('./Function.cjs');\nconst Hash = require('./Hash.cjs');\nconst Identifier = require('./Identifier.cjs');\nconst IdSelector = require('./IdSelector.cjs');\nconst MediaFeature = require('./MediaFeature.cjs');\nconst MediaQuery = require('./MediaQuery.cjs');\nconst MediaQueryList = require('./MediaQueryList.cjs');\nconst NestingSelector = require('./NestingSelector.cjs');\nconst Nth = require('./Nth.cjs');\nconst Number = require('./Number.cjs');\nconst Operator = require('./Operator.cjs');\nconst Parentheses = require('./Parentheses.cjs');\nconst Percentage = require('./Percentage.cjs');\nconst PseudoClassSelector = require('./PseudoClassSelector.cjs');\nconst PseudoElementSelector = require('./PseudoElementSelector.cjs');\nconst Ratio = require('./Ratio.cjs');\nconst Raw = require('./Raw.cjs');\nconst Rule = require('./Rule.cjs');\nconst Selector = require('./Selector.cjs');\nconst SelectorList = require('./SelectorList.cjs');\nconst String = require('./String.cjs');\nconst StyleSheet = require('./StyleSheet.cjs');\nconst TypeSelector = require('./TypeSelector.cjs');\nconst UnicodeRange = require('./UnicodeRange.cjs');\nconst Url = require('./Url.cjs');\nconst Value = require('./Value.cjs');\nconst WhiteSpace = require('./WhiteSpace.cjs');\n\n\n\nexports.AnPlusB = AnPlusB.parse;\nexports.Atrule = Atrule.parse;\nexports.AtrulePrelude = AtrulePrelude.parse;\nexports.AttributeSelector = AttributeSelector.parse;\nexports.Block = Block.parse;\nexports.Brackets = Brackets.parse;\nexports.CDC = CDC.parse;\nexports.CDO = CDO.parse;\nexports.ClassSelector = ClassSelector.parse;\nexports.Combinator = Combinator.parse;\nexports.Comment = Comment.parse;\nexports.Declaration = Declaration.parse;\nexports.DeclarationList = DeclarationList.parse;\nexports.Dimension = Dimension.parse;\nexports.Function = Function.parse;\nexports.Hash = Hash.parse;\nexports.Identifier = Identifier.parse;\nexports.IdSelector = IdSelector.parse;\nexports.MediaFeature = MediaFeature.parse;\nexports.MediaQuery = MediaQuery.parse;\nexports.MediaQueryList = MediaQueryList.parse;\nexports.NestingSelector = NestingSelector.parse;\nexports.Nth = Nth.parse;\nexports.Number = Number.parse;\nexports.Operator = Operator.parse;\nexports.Parentheses = Parentheses.parse;\nexports.Percentage = Percentage.parse;\nexports.PseudoClassSelector = PseudoClassSelector.parse;\nexports.PseudoElementSelector = PseudoElementSelector.parse;\nexports.Ratio = Ratio.parse;\nexports.Raw = Raw.parse;\nexports.Rule = Rule.parse;\nexports.Selector = Selector.parse;\nexports.SelectorList = SelectorList.parse;\nexports.String = String.parse;\nexports.StyleSheet = StyleSheet.parse;\nexports.TypeSelector = TypeSelector.parse;\nexports.UnicodeRange = UnicodeRange.parse;\nexports.Url = Url.parse;\nexports.Value = Value.parse;\nexports.WhiteSpace = WhiteSpace.parse;\n","'use strict';\n\nconst create = require('./create.cjs');\nconst lexer = require('./config/lexer.cjs');\nconst parser = require('./config/parser.cjs');\nconst walker = require('./config/walker.cjs');\n\nconst syntax = create({\n    ...lexer,\n    ...parser,\n    ...walker\n});\n\nmodule.exports = syntax;\n","'use strict';\n\nconst index = require('../scope/index.cjs');\nconst index$1 = require('../atrule/index.cjs');\nconst index$2 = require('../pseudo/index.cjs');\nconst indexParse = require('../node/index-parse.cjs');\n\nconst config = {\n    parseContext: {\n        default: 'StyleSheet',\n        stylesheet: 'StyleSheet',\n        atrule: 'Atrule',\n        atrulePrelude(options) {\n            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);\n        },\n        mediaQueryList: 'MediaQueryList',\n        mediaQuery: 'MediaQuery',\n        rule: 'Rule',\n        selectorList: 'SelectorList',\n        selector: 'Selector',\n        block() {\n            return this.Block(true);\n        },\n        declarationList: 'DeclarationList',\n        declaration: 'Declaration',\n        value: 'Value'\n    },\n    scope: index,\n    atrule: index$1,\n    pseudo: index$2,\n    node: indexParse\n};\n\nmodule.exports = config;\n","'use strict';\n\nconst index = require('../node/index.cjs');\n\nconst config = {\n    node: index\n};\n\nmodule.exports = config;\n","'use strict';\n\nconst SyntaxError = require('./SyntaxError.cjs');\nconst generate = require('./generate.cjs');\nconst parse = require('./parse.cjs');\nconst walk = require('./walk.cjs');\n\n\n\nexports.SyntaxError = SyntaxError.SyntaxError;\nexports.generate = generate.generate;\nexports.parse = parse.parse;\nexports.walk = walk.walk;\n","'use strict';\n\nconst charCodeDefinitions = require('../tokenizer/char-code-definitions.cjs');\nconst utils = require('../tokenizer/utils.cjs');\n\nconst REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\n\nfunction decode(str) {\n    const end = str.length - 1;\n    let decoded = '';\n\n    for (let i = 0; i < str.length; i++) {\n        let code = str.charCodeAt(i);\n\n        if (code === REVERSE_SOLIDUS) {\n            // special case at the ending\n            if (i === end) {\n                // if the next input code point is EOF, do nothing\n                break;\n            }\n\n            code = str.charCodeAt(++i);\n\n            // consume escaped\n            if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {\n                const escapeStart = i - 1;\n                const escapeEnd = utils.consumeEscaped(str, escapeStart);\n\n                i = escapeEnd - 1;\n                decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n            } else {\n                // \\r\\n\n                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n                    i++;\n                }\n            }\n        } else {\n            decoded += str[i];\n        }\n    }\n\n    return decoded;\n}\n\n// https://drafts.csswg.org/cssom/#serialize-an-identifier\n// § 2.1. Common Serializing Idioms\nfunction encode(str) {\n    let encoded = '';\n\n    // If the character is the first character and is a \"-\" (U+002D),\n    // and there is no second character, then the escaped character.\n    // Note: That's means a single dash string \"-\" return as escaped dash,\n    // so move the condition out of the main loop\n    if (str.length === 1 && str.charCodeAt(0) === 0x002D) {\n        return '\\\\-';\n    }\n\n    // To serialize an identifier means to create a string represented\n    // by the concatenation of, for each character of the identifier:\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n        if (code === 0x0000) {\n            encoded += '\\uFFFD';\n            continue;\n        }\n\n        if (\n            // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F ...\n            // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n            code <= 0x001F || code === 0x007F ||\n            // [or] ... is in the range [0-9] (U+0030 to U+0039),\n            (code >= 0x0030 && code <= 0x0039 && (\n                // If the character is the first character ...\n                i === 0 ||\n                // If the character is the second character ... and the first character is a \"-\" (U+002D)\n                i === 1 && str.charCodeAt(0) === 0x002D\n            ))\n        ) {\n            // ... then the character escaped as code point.\n            encoded += '\\\\' + code.toString(16) + ' ';\n            continue;\n        }\n\n        // If the character is not handled by one of the above rules and is greater\n        // than or equal to U+0080, is \"-\" (U+002D) or \"_\" (U+005F), or is in one\n        // of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to U+005A),\n        // or \\[a-z] (U+0061 to U+007A), then the character itself.\n        if (charCodeDefinitions.isName(code)) {\n            encoded += str.charAt(i);\n        } else {\n            // Otherwise, the escaped character.\n            encoded += '\\\\' + str.charAt(i);\n        }\n    }\n\n    return encoded;\n}\n\nexports.decode = decode;\nexports.encode = encode;\n","'use strict';\n\nconst index$1 = require('./syntax/index.cjs');\nconst version = require('./version.cjs');\nconst create = require('./syntax/create.cjs');\nconst List = require('./utils/List.cjs');\nconst Lexer = require('./lexer/Lexer.cjs');\nconst index = require('./definition-syntax/index.cjs');\nconst clone = require('./utils/clone.cjs');\nconst names$1 = require('./utils/names.cjs');\nconst ident = require('./utils/ident.cjs');\nconst string = require('./utils/string.cjs');\nconst url = require('./utils/url.cjs');\nconst types = require('./tokenizer/types.cjs');\nconst names = require('./tokenizer/names.cjs');\nconst TokenStream = require('./tokenizer/TokenStream.cjs');\n\nconst {\n    tokenize,\n    parse,\n    generate,\n    lexer,\n    createLexer,\n\n    walk,\n    find,\n    findLast,\n    findAll,\n\n    toPlainObject,\n    fromPlainObject,\n\n    fork\n} = index$1;\n\nexports.version = version.version;\nexports.createSyntax = create;\nexports.List = List.List;\nexports.Lexer = Lexer.Lexer;\nexports.definitionSyntax = index;\nexports.clone = clone.clone;\nexports.isCustomProperty = names$1.isCustomProperty;\nexports.keyword = names$1.keyword;\nexports.property = names$1.property;\nexports.vendorPrefix = names$1.vendorPrefix;\nexports.ident = ident;\nexports.string = string;\nexports.url = url;\nexports.tokenTypes = types;\nexports.tokenNames = names;\nexports.TokenStream = TokenStream.TokenStream;\nexports.createLexer = createLexer;\nexports.find = find;\nexports.findAll = findAll;\nexports.findLast = findLast;\nexports.fork = fork;\nexports.fromPlainObject = fromPlainObject;\nexports.generate = generate;\nexports.lexer = lexer;\nexports.parse = parse;\nexports.toPlainObject = toPlainObject;\nexports.tokenize = tokenize;\nexports.walk = walk;\n","import React, {memo, useEffect, useState} from 'react'\n// @ts-ignore\nimport * as csstree from 'css-tree'\nimport './MatchGraph.css'\n\ntype Elements = HTMLElement | SVGElement\n\nfunction setupElement (el: Elements, attrs: any, children: any) {\n  if (typeof attrs === 'string') {\n    attrs = {\n      class: attrs\n    }\n  }\n\n  for (let attrName in attrs) {\n    if (attrName.startsWith('on')) {\n      el.addEventListener(attrName.substring(2), attrs[attrName])\n    } else {\n      el.setAttribute(attrName, attrs[attrName])\n    }\n  }\n\n  if (Array.isArray(children)) {\n    children.forEach(child => el.appendChild(child && child.nodeType ? child : createText(child)))\n  } else if (typeof children === 'string') {\n    el.innerHTML = children\n  }\n\n  return el\n}\n\nfunction createElement (tag: string, attrs: any, children?: any) {\n  return setupElement(document.createElement(tag), attrs, children) // FIXME: documentを使用しないようにリファクタリングする\n}\n\nfunction createSvgElement (tag: string, attrs: any, children?: any) {\n  return setupElement(document.createElementNS('http://www.w3.org/2000/svg', tag), attrs, children)\n}\n\nfunction createText (text: string) {\n  return document.createTextNode(String(text))\n}\n\nconst SYNTAX_URL = 'https://csstree.github.io/docs/syntax/'\n\ntype MatchNode = {\n  type: string\n  match: any\n  name: string | boolean\n  value: boolean\n  map: any\n  then: any\n  else: any\n}\n\ntype Props = {\n  name: string\n}\n\nconst MatchGraph = (props: Props) => {\n  const [onShow, setOnShow] = useState(false);\n  useEffect(() => {\n    setOnShow(true);\n  }, []);\n\n  if (!onShow || typeof window === 'undefined') return null\n\n  const { name } = props\n  const match = csstree.lexer.getProperty(name) ?? csstree.lexer.getType(name) // FIXME: check property or type\n  if (match === null) return null\n  const walk = (node: MatchNode, container: Elements): boolean | never => {\n    if (node.type === 'MatchGraph') {\n      return walk(node.match, container)\n    }\n\n    let complex = false\n    let el\n    let contentEl\n    let mainEl\n\n    el = createElement('div', 'node-wrapper', [\n      contentEl = createElement('div', 'node-content', [\n        mainEl = createElement('div', 'node')\n      ])\n    ])\n\n    if (visited.has(node)) {\n      mainEl.classList.add('node_recursive')\n      mainEl.innerHTML = 'Recursive'\n      container.appendChild(el)\n      return true\n    }\n\n    if (node.type === 'If') {\n      visited.set(node, node.value)\n      ifStack.push(node)\n    }\n\n    elByNode.set(node, {\n      root: el,\n      content: contentEl,\n      main: mainEl\n    })\n\n    switch (node.type) {\n      case 'Match': {\n        mainEl.classList.add('node_match')\n        mainEl.innerHTML = node.type\n\n        let toNode = null\n        for (let i = ifStack.length - 1, prev = node; i >= 0; i--) {\n          const ifStackItem = ifStack[i]\n\n          if (prev === ifStackItem.then) {\n            toNode = ifStackItem.then\n            break\n          }\n\n          prev = ifStackItem\n        }\n\n        if (toNode !== null) {\n          laterConnections.push({\n            from: mainEl,\n            to: toNode,\n            num: 0,\n            total: { count: 0 }\n          })\n        }\n        break\n      }\n\n      case 'Mismatch': {\n        mainEl.classList.add('node_mismatch')\n        mainEl.innerHTML = node.type\n\n        let toNode = null\n        for (let i = ifStack.length - 1, prev = node; i >= 0; i--) {\n          const ifStackItem = ifStack[i]\n\n          if (prev === ifStackItem.then) {\n            toNode = ifStackItem.else\n            break\n          }\n\n          prev = ifStackItem\n        }\n\n        if (toNode !== null) {\n          laterConnections.push({\n            from: mainEl,\n            to: toNode,\n            num: 0,\n            total: { count: 0 }\n          })\n        }\n        break\n      }\n\n      case 'DisallowEmpty':\n        mainEl.classList.add('node_disallow-empty')\n        mainEl.innerHTML = node.type\n        break\n\n      case 'Type':\n      case 'Property':\n      case 'Keyword':\n      case 'Function':\n      case 'Token':\n      case 'String':\n      case 'Comma': {\n        if (!node.match) {\n          let key: string | boolean = false\n\n          switch (node.type) {\n            case 'Type':\n              key = `<a href=\"${SYNTAX_URL}#Type:` + node.name + '\" target=\"_blank\">&lt;' + node.name + '&gt;</a>'\n              break\n            case 'Property':\n              key = `<a href=\"${SYNTAX_URL}#Property:` + node.name + '\" target=\"_blank\">&lt;\\'' + node.name + '\\'&gt;</a>'\n              break\n            case 'Function':\n            case 'Keyword':\n              key = node.name\n              break\n            case 'Token':\n            case 'String':\n              key = node.value\n              break\n            case 'Comma':\n              key = ','\n              break\n          }\n\n          mainEl.classList.add('node_check')\n          mainEl.innerHTML =\n            '<span class=\"node__label\">' + node.type + '</span>' +\n            '<span class=\"node__key\">' + key + '</span>'\n        }\n        break\n      }\n\n      default: {\n        mainEl.classList.add('node_default')\n\n        const nestedEl = el.appendChild(createElement('div', 'nested nested_labeled'))\n\n        mainEl.appendChild(createElement('div', 'node__type', node.type))\n        complex = true\n\n        let nestedSimpleEl = nestedEl\n        const values = node.type === 'Enum' ? node.map : node\n        const nestedOffset = {\n          count: 0\n        }\n        for (const key in values) {\n          if (values === node && key === 'syntax' || key === 'type') {\n            continue\n          }\n\n          const value = values[key]\n          const isNested = value && typeof value === 'object'\n          const field = mainEl.appendChild(\n            createElement(\n              'div',\n              'node-field',\n              '<span class=\"node-field-label\">' +\n              key +\n              '</span>' +\n              '<span>' +\n              (isNested\n                  ? '<span class=\"connection-dot\"></span>'\n                  : typeof value === 'function' ? '[function]' : JSON.stringify(value)\n              ) +\n              '</span>'\n            )\n          )\n\n          if (isNested) {\n            if (walk(value, nestedEl)) {\n              // complex\n              nestedSimpleEl = elByNode.get(value)\n            } else {\n              // simple\n              if (nestedEl !== nestedSimpleEl) {\n                // @ts-ignore\n                nestedSimpleEl.content.appendChild(elByNode.get(value).root)\n              }\n            }\n\n            connections.push({\n              from: field.lastChild?.lastChild,\n              to: elByNode.get(value)?.main,\n              num: nestedOffset.count++,\n              total: nestedOffset\n            })\n          }\n        }\n      }\n    }\n\n    container.appendChild(el)\n\n    if (node.type === 'If') {\n      ifStack.pop()\n    }\n\n    return complex\n  }\n\n  const visited = new Map()\n  const elByNode = new Map()\n  const ifStack: MatchNode[] = []\n  const laterConnections = []\n  type Connections = { from: ChildNode | null | undefined; to: any; num: number; total: { count: number } }\n  const connections: Connections[] = []\n\n  const matchTreeEl = createElement('div', 'graph')\n  let matchTreeConnectionsEl: Elements\n\n  walk(match.match, matchTreeEl)\n\n  matchTreeConnectionsEl = createSvgElement('svg', 'connections-canvas')\n\n  // build connections\n  setTimeout(() => {\n    const baseBox = matchTreeEl.getBoundingClientRect()\n\n    connections\n      .map(function (connection) {\n        // @ts-ignore\n        const from = connection.from?.getBoundingClientRect()\n        const to = connection.to.getBoundingClientRect()\n        const back = from.right > to.left\n\n        const x1 = from.right - baseBox.left\n        const y1 = from.top - baseBox.top + from.height / 2\n        const x2 = (back ? to.right + 1 : to.left - 1) - baseBox.left - 7\n        const y2 = to.top - baseBox.top + 10\n        const midX = back ? 16 : 12 + Math.abs(connection.num - connection.total.count) * 5\n\n        if (y1 === y2) {\n          return [\n            'M', x1, y1,\n            'H', x2\n          ].join(' ')\n        }\n\n        const arc = Math.abs(y1 - y2) > 16 ? 8 : 0\n        const arcY = y2 < y1 ? -arc : arc\n\n        return [\n          'M', x1, y1,\n          'h', midX - arc,\n          'q', [arc, 0], [arc, arcY],\n          'V', y2 - arcY,\n          'q', [0, arcY], [back ? -arc : arc, arcY],\n          'H', x2\n        ].join(' ')\n      })\n      .forEach(function (path) {\n        matchTreeConnectionsEl.appendChild(\n          createSvgElement('path', {\n            class: 'connection',\n            d: path\n          })\n        )\n      })\n  }, 0)\n\n  return <div className=\"view-match-graph\">\n    <MatchGraphConnectionMarker />\n    <div\n      className=\"canvas\"\n      ref={ref => {\n        if (ref?.childElementCount === 0) {\n          ref.append(matchTreeConnectionsEl, matchTreeEl)\n        }\n      }}\n    />\n  </div>\n}\n\nconst MatchGraphConnectionMarker = () => (\n  <svg style={{ position: 'absolute', zIndex: -1, width: 0, height: 0 }}>\n    <marker\n      id=\"match-graph-connection-marker\"\n      viewBox=\"0 0 5 10\"\n      refX=\"0\"\n      refY=\"5\"\n      markerUnits=\"strokeWidth\"\n      markerWidth=\"6\"\n      markerHeight=\"4\"\n      orient=\"auto\"\n    >\n      <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"rgba(160, 160, 160, 0.65)\"></path>\n    </marker>\n  </svg>\n)\n\nexport default memo(MatchGraph)\n"],"names":["types","AtKeyword","BadString","BadUrl","CDC","CDO","Colon","Comma","Comment","Delim","Dimension","EOF","Function","Hash","Ident","LeftCurlyBracket","LeftParenthesis","LeftSquareBracket","Number","Percentage","RightCurlyBracket","RightParenthesis","RightSquareBracket","Semicolon","String","Url","WhiteSpace","isDigit","code","isUppercaseLetter","isLowercaseLetter","isLetter","isNonAscii","isNameStart","isNonPrintable","isNewline","isWhiteSpace","isValidEscape","first","second","CATEGORY","Array","i","length","charCodeDefinitions","DigitCategory","EofCategory","NameStartCategory","NonPrintableCategory","WhiteSpaceCategory","charCodeCategory","isBOM","isHexDigit","isIdentifierStart","third","isName","isNumberStart","require$$0","getCharCode","source","offset","charCodeAt","getNewlineLength","cmpChar","testStr","referenceCode","findDecimalNumberEnd","consumeEscaped","maxOffset","Math","min","utils","cmpStr","start","end","referenceStr","testCode","consumeBadUrlRemnants","consumeName","consumeNumber","sign","decodeEscaped","escaped","parseInt","fromCodePoint","findWhiteSpaceEnd","findWhiteSpaceStart","names","adoptBuffer_1","adoptBuffer","buffer","size","Uint32Array","max","require$$1","computeLinesAndColumns","host","sourceLength","startOffset","lines","columns","line","startLine","column","startColumn","computed","OffsetToLocation_1","OffsetToLocation","constructor","this","setSource","getLocation","filename","getLocationRange","require$$2","require$$3","OFFSET_MASK","TYPE_SHIFT","balancePair","Map","TokenStream_1","TokenStream","tokenize","reset","eof","tokenIndex","tokenType","tokenStart","firstCharOffset","tokenEnd","offsetAndType","balance","tokenCount","balanceCloseType","balanceStart","type","balancePrev","get","next","lookupType","lookupOffset","lookupValue","getTokenStart","substrToCursor","substring","isBalanceEdge","pos","isDelim","skip","skipSC","skipUntilBalanced","startToken","stopConsume","balanceEnd","cursor","loop","forEachToken","fn","item","dump","tokens","index","idx","chunk","require$$4","require$$5","tokenizer","tokenTypes","tokenNames","onToken","consumeNumericToken","consumeIdentLikeToken","nameStartOffset","consumeUrlToken","consumeStringToken","endingCodePoint","nextCode","indexOf","releasedCursors","List","static","data","prev","head","tail","createItem","allocateCursor","releaseCursor","updateCursors","prevOld","prevNew","nextOld","nextNew","Symbol","iterator","isEmpty","last","fromArray","array","toArray","toJSON","forEach","thisArg","call","forEachRight","reduce","initialValue","acc","reduceRight","some","map","result","appendData","filter","nextUntil","prevUntil","clear","copy","prepend","prependData","append","insert","before","Error","insertData","remove","push","pop","unshift","shift","prependList","list","insertList","appendList","replace","oldItem","newItemOrList","List_1","createCustomError_1","createCustomError","name","message","error","Object","create","SyntaxError","prototype","errorStack","assign","stack","TAB_REPLACEMENT","sourceFragment","extraLines","processLines","slice","padStart","maxNumLength","join","split","endLine","cutLeft","substr","match","OFFSET_CORRECTION","MAX_LINE_LENGTH","Boolean","_SyntaxError","isNaN","formattedMessage","sequence","readSequence","recognizer","children","createList","space","context","child","getNode","undefined","onWhiteSpace","require$$6","require$$7","require$$8","NOOP","createParseContext","fetchParseValues","dict","parse","createParser","config","needPositions","onParseError","onParseErrorThrow","locationMap","parser","parseConfig","scope","atrule","pseudo","node","parseContext","processConfig","parseAtrulePrelude","parseRulePrelude","parseValue","parseCustomProperty","consumeUntilBalanceEnd","consumeUntilLeftCurlyBracket","consumeUntilLeftCurlyBracketOrSemicolon","consumeUntilExclamationMarkOrSemicolon","consumeUntilSemicolonIncluded","createSingleNodeList","getFirstListNode","getLastListNode","parseWithFallback","consumer","fallback","e","fallbackNode","lookupNonWSType","offsetStart","offsetEnd","charCode","str","consume","eat","consumeFunctionName","number","tokenName","m","toUpperCase","test","eatIdent","eatDelim","fromCharCode","getLocationFromList","loc","location","source_","options","positions","onComment","value","ast","intToCharMap","base64","encode","TypeError","decode","base64Vlq","aValue","digit","encoded","vlq","toVLQSigned","VLQ_BASE","aStr","aIndex","aOutParam","continuation","shifted","strLen","charAt","rest","exports","getArg","aArgs","aName","aDefaultValue","arguments","urlRegexp","dataUrlRegexp","urlParse","aUrl","scheme","auth","port","path","urlGenerate","aParsedUrl","url","f","cache","normalize","aPath","isAbsolute","parts","part","up","splice","input","temp","aRoot","aPathUrl","aRootUrl","joined","relative","level","lastIndexOf","supportsNullProto","identity","s","isProtoString","strcmp","aStr1","aStr2","toSetString","fromSetString","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","originalLine","originalColumn","generatedColumn","generatedLine","compareByOriginalPositionsNoSource","compareByGeneratedPositionsDeflated","onlyCompareGenerated","compareByGeneratedPositionsDeflatedNoLine","compareByGeneratedPositionsInflated","parseSourceMapInput","JSON","computeSourceURL","sourceRoot","sourceURL","sourceMapURL","parsed","util","has","hasOwnProperty","hasNativeMap","ArraySet","_array","_set","aArray","aAllowDuplicates","set","len","add","getOwnPropertyNames","sStr","isDuplicate","at","aIdx","arraySet","MappingList","_sorted","_last","unsortedForEach","aCallback","aThisArg","aMapping","lineA","lineB","columnA","columnB","sort","mappingList","base64VLQ","SourceMapGenerator","_file","_sourceRoot","_skipValidation","_sources","_names","_mappings","_sourcesContents","_version","fromSourceMap","aSourceMapConsumer","generator","file","eachMapping","mapping","newMapping","generated","original","addMapping","sources","sourceFile","sourceRelative","content","sourceContentFor","setSourceContent","_validateMapping","aSourceFile","aSourceContent","keys","applySourceMap","aSourceMapPath","newSources","newNames","originalPositionFor","aGenerated","aOriginal","aSource","stringify","_serializeMappings","nameIdx","sourceIdx","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","mappings","_generateSourcesContent","aSources","aSourceRoot","key","version","sourcesContent","toString","sourceMapGenerator","sourceMapGenerator_js","trackNodes","Set","sourceMap","generateSourceMap","handlers","activatedGenerated","activatedMapping","sourceMappingActive","origHandlersNode","nodeLine","nodeColumn","origHandlersEmit","emit","auto","origHandlersResult","css","specPairs","safePairs","concat","createMap","pairs","isWhiteSpaceRequired","prevCode","nextCharCode","spec","safe","tokenBefore","processChildren","delimeter","processChunk","token","createGenerator","types$1","generate","publicApi","decorator","mode","createConvertor","walk","fromPlainObject","enter","toPlainObject","leave","noop","ensureFunction","invokeForType","getWalkersFromStructure","nodeType","structure","walkers","fieldTypes","walker","nullable","isArray","fieldType","walkContext","fields","createTypeIterator","reverse","contextName","useContext","walkReducer","prevContextValue","field","ref","createFastTraveralMap","StyleSheet","Atrule","Rule","Block","DeclarationList","Declaration","createWalker","getTypesFromConfig","iteratorsNatural","iteratorsReverse","breakWalk","skipNode","fastTraversalIteratorsNatural","fastTraversalIteratorsReverse","root","walkNode","enterRet","iterators","ret","break","stylesheet","atrulePrelude","rule","selector","block","declaration","function","visit","find","found","findLast","findAll","internalGenerate","decorate","forceBraces","compact","combinator","terms","term","explicit","generateSequence","disallowEmpty","multiplier","comma","generateMultiplier","opts","generateTypeOpts","generate_1","defaultLoc","fromLoc","point","buildLoc","extra","SyntaxMatchError","syntax","matchResult","mismatchOffset","mismatchLength","longestMatch","mismatchNode","badNode","entries","locateMismatch","rawMessage","SyntaxReferenceError","referenceName","reference","keywords","properties","keyword","toLowerCase","descriptor","custom","isCustomProperty","vendor","getVendorPrefix","freeze","basename","prefix","property","hack","vendorPrefix","secondDashIndex","genericConst","cssWideKeywords","HYPHENMINUS","DISALLOW_SIGN","getNextToken","checkInteger","valueOffset","disallowSign","consumeB","offset_","genericAnPlusB","hexSequence","allowDash","hexlen","withQuestionMarkSequence","consumed","genericUrange","consumedHexLength","startsWith","calcFunctionNames","eqStr","actual","expected","eqStrAny","isPostfixIeHack","outOfRange","numEnd","num","calc","balanceStash","scan","consumeFunction","expectedTokenType","dimension","numberEnd","reverseSolidusOffset","unit","zero","productionTypes","string","ident","percentage","integer","urange","createDemensionTypes","units","angle","decibel","frequency","flex","resolution","semitones","time","generic","createGenericTypes","astToTokens","curNode","tmp","prepareTokens_1","stringToTokens","Tokenizer","nextNonWsCode","findWsEnd","substringToPos","peek","LEFTCURLYBRACKET","NAME_CHAR","Uint8Array","_","COMBINATOR_PRECEDENCE","scanSpaces","scanWord","scanNumber","scanString","readMultiplierRange","maybeMultiplied","range","readMultiplier","maybeToken","ch","readType","readTypeRange","regroupTerms","combinators","createGroup","a","b","subgroupStart","readImplicitGroup","prevToken","prevTokenPos","readKeywordOrFunction","readGroup","readProperty","parse_1","tokenizer$1","MATCH","MISMATCH","DISALLOW_EMPTY","createCondition","thenBranch","elseBranch","else","then","isFunctionType","isEnumCapatible","buildGroupMatchGraph","atLeastOneTermMatched","all","thenClause","newGroupTerm","buildMatchGraphInternal","matchTerm","buildMultiplierMatchGraph","matchGraph","buildMatchGraph","syntaxTree","EXIT_REASON_MATCH","reverseList","areStringsEqualCaseInsensitive","isCommaContextStart","isContextEdgeDelim","isCommaContextEnd","internalMatch","state","syntaxes","moveToNextToken","nextIndex","stateSnapshotFromSyntax","nextState","matchStack","syntaxStack","thenStack","pushThenStack","pushElseStack","elseStack","addTokenToMatch","syntaxStash","closeSyntax","iterationCount","exitReason","mask","matchFlag","lastTokenIndex","floor","syntaxDict","dictSyntax","keywordName","console","warn","reason","iterations","matchAsList","matchAsTree","hostStack","getTrace","shouldPutToTrace","matched","hasMatch","matchNode","testNode","trace","isKeyword","isProperty","isType","getFirstMatchNode","getLastMatchNode","search","matchFragments","lexer","fragments","findFragments","nodes","parent","isValidNumber","isFinite","isValidLocation","createNodeStructureChecker","valid","processStructure","docs","docsTypes","check","getStructureFromConfig","walk_1","prepareTokens","require$$9","require$$10","require$$11","require$$12","require$$13","cssWideKeywordsSyntax","dumpMapSyntax","syntaxAsAst","dumpAtruleMapSyntax","prelude","descriptors","buildMatchResult","matchSyntax","useCssWideKeywords","valueHasVar","appendOrSet","sliceProps","obj","props","prop","includes","Lexer_1","Lexer","structure$1","atrules","group","addType_","addAtrule_","addProperty_","checkStructure","collectWarning","warns","createDescriptor","serializable","defineProperty","descName","checkAtruleName","atruleName","getAtrule","checkAtrulePrelude","checkAtruleDescriptorName","descriptorName","error$1","checkPropertyName","propertyName","getProperty","matchAtrulePrelude","matchAtruleDescriptor","matchDeclaration","matchProperty","matchType","typeName","typeSyntax","getType","findValueFragments","findDeclarationValueFragments","findAllFragments","apply","fallbackBasename","getAtrulePrelude","getAtruleDescriptor","declarators","validate","broken","brokenMap","brokenTypes","brokenProperties","pretty","mix_1","dest","src","patch","exists","current","descriptorValue","create$2","create$3","create$1","mix","createSyntax","createLexer","fork","extension","base","create_1","dataPatch","mdnAtrules","mdnProperties","extendSyntax","patchDictionary","patchDict","trim","definitions","atrulePatch","patchAtrules","preprocessAtrules","PLUSSIGN","N","checkTokenIsInteger","expectCharCode","msg","AnPlusB","consumeRaw","Raw","isDeclarationBlockAtrule","isDeclaration","nameLowerCase","AtrulePrelude","bind","getAttributeName","expectIdent","getOperator","matcher","flags","AttributeSelector","Identifier","consumeRule","consumeRawDeclaration","consumeDeclaration","isStyleBlock","Brackets","ClassSelector","Combinator","consumeValueRaw","consumeCustomPropertyRaw","consumeValue","startValueToken","Value","important","getImportant","customProperty","valueStart","_Function","xxx","IdSelector","MediaFeature","Ratio","MediaQuery","MediaQueryList","NestingSelector","Nth","nth","SelectorList","_Number","Operator","Parentheses","PseudoClassSelector","PseudoElementSelector","left","right","getOffsetExcludeWS","consumeUntil","excludeWhiteSpace","endOffset","consumePrelude","Selector","firstChar","decoded","escapeStart","escapeEnd","apostrophe","quote","quoteCode","wsBeforeHexIsNeeded","_String","eatIdentifierOrAsterisk","TypeSelector","eatHexSequence","eatQuestionMarkSequence","count","scanUnicodeRange","hexLength","UnicodeRange","SPACE","require$$14","require$$15","require$$16","require$$17","require$$18","require$$19","require$$20","require$$21","require$$22","Number$1","require$$23","require$$24","require$$25","require$$26","require$$27","require$$28","require$$29","require$$30","require$$31","require$$32","require$$33","String$1","require$$34","require$$35","require$$36","require$$37","require$$38","require$$39","require$$40","_default","_var","startIndex","isPlusMinusOperator","expression","var","parentheses","atrule_1","import","media","nest","page","supports","selectorList","identList","pseudo_1","dir","lang","matches","is","where","not","slotted","indexParse","syntax_1","default","mediaQueryList","mediaQuery","declarationList","definitionSyntax","index$1","names$1","lexer_1","setupElement","el","attrs","class","attrName","addEventListener","setAttribute","appendChild","text","document","createTextNode","innerHTML","createElement","tag","createSvgElement","createElementNS","SYNTAX_URL","MatchGraphConnectionMarker","_jsx","style","position","zIndex","width","height","id","viewBox","refX","refY","markerUnits","markerWidth","markerHeight","orient","d","fill","MatchGraph$1","memo","onShow","setOnShow","useState","useEffect","window","_a","csstree.lexer","container","contentEl","mainEl","complex","visited","classList","ifStack","elByNode","main","ifStackItem","nestedEl","nestedSimpleEl","values","nestedOffset","isNested","connections","from","lastChild","to","_b","total","matchTreeEl","matchTreeConnectionsEl","setTimeout","baseBox","getBoundingClientRect","connection","back","x1","y1","top","x2","y2","midX","abs","arc","arcY","_jsxs","className","childElementCount"],"mappings":"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"}